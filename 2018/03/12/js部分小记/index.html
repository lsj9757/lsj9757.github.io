<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="前端," />










<meta name="description" content="一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。12345678var data = $(&amp;quot;#button&amp;quot;).serializeArray();    postData = &amp;#123;&amp;#125;;    $(data).each(function(i)&amp;#123;       postData[this.name] = this.va">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="web小记">
<meta property="og:url" content="http://yoursite.com/2018/03/12/js部分小记/index.html">
<meta property="og:site_name" content="save the world by program">
<meta property="og:description" content="一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。12345678var data = $(&amp;quot;#button&amp;quot;).serializeArray();    postData = &amp;#123;&amp;#125;;    $(data).each(function(i)&amp;#123;       postData[this.name] = this.va">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/js1.png">
<meta property="og:image" content="http://yoursite.com/images/csj.jpg">
<meta property="og:image" content="http://yoursite.com/images/yxl.png">
<meta property="og:image" content="http://yoursite.com/images/promise1.jpg">
<meta property="og:image" content="http://yoursite.com/images/http1.jpg">
<meta property="og:image" content="http://yoursite.com/images/http2.jpg">
<meta property="og:updated_time" content="2018-05-04T12:29:41.244Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="web小记">
<meta name="twitter:description" content="一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。12345678var data = $(&amp;quot;#button&amp;quot;).serializeArray();    postData = &amp;#123;&amp;#125;;    $(data).each(function(i)&amp;#123;       postData[this.name] = this.va">
<meta name="twitter:image" content="http://yoursite.com/images/js1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/12/js部分小记/"/>





  <title>web小记 | save the world by program</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">save the world by program</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上身能走马，提臀能抗山</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/js部分小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/hsq.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="save the world by program">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">web小记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T17:07:25+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。"><a href="#一-比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。" class="headerlink" title="一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。"></a>一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data = $(&quot;#button&quot;).serializeArray();</span><br><span class="line">    postData = &#123;&#125;;</span><br><span class="line">    $(data).each(function(i)&#123;</span><br><span class="line">       postData[this.name] = this.value;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(postData);</span><br><span class="line">    // 将获取到的数据post给服务器</span><br><span class="line">   $.post..........</span><br></pre></td></tr></table></figure>
<p>一般也可以直接获取比如：var username = $(‘input[name=”username”]’).val();<br>array_unique()是排重方法<br>exit(json_encode(array));输出JSON数据</p>
<h1 id="二-基础函数小结"><a href="#二-基础函数小结" class="headerlink" title="二.基础函数小结"></a>二.基础函数小结</h1><p>…<br><a id="more"></a></p>
<h2 id="js类："><a href="#js类：" class="headerlink" title="js类："></a>js类：</h2><blockquote>
<p>1-indexOf()-方法可返回某个指定的字符串值在字符串中首次出现的位置/toFixed(n),保留n位小数</p>
</blockquote>
<blockquote>
<p>2-forEach()-方法用于调用数组的每个元素,并将元素传递给回调函数arr.forEach(function(e,i){e==….e是值，i是下标</p>
</blockquote>
<blockquote>
<p>3-splice()-方法用于插入、删除或替换数组的元素。array.splice(start, deleteCount, item1, item2, …)<br>//splice方法会改变数组长度，当减掉一个元素后，<br>后面的元素都会前移，因此需要相应减少i的值。</p>
</blockquote>
<blockquote>
<p>4-slice</p>
</blockquote>
<p>(begin 可选从该索引处开始提取原数组中的元素（从0开始）。<br>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。<br>如果省略 begin，则 slice 从索引 0 开始。<br>end在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。)<br>方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。var newArr=arr1.slice(0);(浅拷贝)</p>
<blockquote>
<p>5-concat()-方法用于连接两个或多个数组。(也可以arr1.push.apply(arr1,arr2);)</p>
</blockquote>
<blockquote>
<p>6-unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。shift()删除并返回数组的第一个元素</p>
</blockquote>
<blockquote>
<p>7-array.fill(value, start, end)</p>
</blockquote>
<p>value 必需。填充的值。<br>start 可选。开始填充位置。<br>end 可选。停止填充位置 (默认为 array.length)</p>
<blockquote>
<p>8-array.filter(得到过滤结果)/array.some(得到过滤true/false)：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//数组去重：</span><br><span class="line">var r1 = arr.filter(function (element, index, self) &#123;</span><br><span class="line"> return self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line">var r2 = Array.from(new Set(arr));</span><br><span class="line">var r3 = [...new Set(arr)];</span><br><span class="line"></span><br><span class="line">let r4 = arr.sort().reduce((init, current)=&gt;&#123;</span><br><span class="line">    if(init.length===0 || init[init.length-1]!==current)&#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对象数组去重：</span><br><span class="line">let person = [</span><br><span class="line">     &#123;id: 0, name: &quot;小明&quot;&#125;,</span><br><span class="line">     &#123;id: 1, name: &quot;小张&quot;&#125;,</span><br><span class="line">     &#123;id: 0, name: &quot;小周&quot;&#125; </span><br><span class="line">];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">person = person.reduce((cur,next) =&gt; &#123;</span><br><span class="line">    obj[next.id] ? &quot;&quot; : obj[next.id] = true &amp;&amp; cur.push(next);//因为push后返回长度</span><br><span class="line">    return cur;</span><br><span class="line">&#125;,[]) //设置cur默认类型为数组，并且初始值为空的数组</span><br><span class="line">console.log(person);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//扁平化数组：</span><br><span class="line">function flatten1(arr) &#123;</span><br><span class="line">    return arr.toString().split(&apos;,&apos;).map(function(item)&#123;</span><br><span class="line">        return +item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; //只能全是数字</span><br><span class="line">function flatten2(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125; //reduce实现</span><br><span class="line">function flatten3(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;//扩展运算符实现</span><br></pre></td></tr></table></figure>
<blockquote>
<p>9-Object.keys() </p>
</blockquote>
<p>方法会返回一个由给定&lt;对象&gt;的所有&lt;可枚举自身属性&gt;的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）<br>(Obeject.keys()==0判断对象是否为空)</p>
<blockquote>
<p>10-toString()</p>
</blockquote>
<p>通过num.toString(2)能直接将num转换为2进制数格式的字符串&lt;.toString前必须跟变量，直接10.toSring(2)是不行的&gt;<br>-parseInt(x,N)可以把N进制的数x转换成10进制。<br>//2进制转16进制<br>parseInt(‘10110110’,2).toString(16);</p>
<blockquote>
<p>11-split()</p>
</blockquote>
<p>方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。</p>
<blockquote>
<p>12-join()</p>
</blockquote>
<p>方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。</p>
<p>-Array.form:<br>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。<br>Array.isArray() 用于确定传递的值是否是一个 Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const bar = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">Array.from(bar);</span><br><span class="line">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">Array.from(&apos;foo&apos;);</span><br><span class="line">// [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>13-因为点表示法中，key为标识符，必需逐字输入，而数组表示法中为字符串，是一种数据结构，js可以在运行中操作并创建</p>
</blockquote>
<blockquote>
<p>14-RegExpObject.test(string)</p>
</blockquote>
<p>test() 方法用于检测一个字符串是否匹配某个模式.如果字符串中有匹配的值返回 true ,否则返回 false。</p>
<blockquote>
<p>15-<br>var str = “A”;str.charCodeAt();  // 65<br>var num = 97;String.fromCharCode(num);  // ‘a’</p>
</blockquote>
<blockquote>
<p>16-Object.keys(n).sort((x,y) =&gt;n[x]&lt; n[y])//对对象内的键值进行排序;<br>arr.sort((x,y)=&gt;x&lt;y)//对数组排序</p>
</blockquote>
<blockquote>
<p>17-document.getElementById(“button1”).style.backgroundColor=”red”;</p>
</blockquote>
<blockquote>
<p>18-解析器在向执行环境中加载数据时，对函数声明和函数表达式并不是一视同仁，解析器会率先读取函数声明，并在其执行任何代码之前可用。所以解析器会依次读入两个函数，且后面的函数会覆盖前面的函数，因此实际上两个语句都调用的是第二个函数</p>
</blockquote>
<blockquote>
<p>19-JavaScript RegExp(是js内置函数(还有Error/Date/Function/Boolean/Array/String/Number/Obejct))</p>
</blockquote>
<p>JavaScript RegExp 对象有3个方法：test()、exec()、compile()<br>test()：检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回true，否则返回false；<br>exec()：检索字符串中与正则表达式匹配的值，返回一个数组，存放匹配的结果；如果未找到，返回null；<br>compile():可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。<br>注：match只是支持正则表达式的String对象的方法，不是RegExp对象的方法。</p>
<blockquote>
<p>20-substring() </p>
</blockquote>
<p>方法用于提取字符串中介于两个指定下标之间的字符。&lt;和数组不一样的是(0,1)代表第一个字符,(1)代表从第二个字符开始至最后一个字符&gt;</p>
<blockquote>
<p>21-字符串和数组中length是属性没有.()！！</p>
</blockquote>
<blockquote>
<p>22-字符数组变整形数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numArray = strArray.map((value)=&gt;&#123;</span><br><span class="line">    return  parseInt(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不用遍历，那只能用老技术了..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = JSON.parse(&apos;[&apos; + String([&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]) + &apos;]&apos;)</span><br><span class="line">console.log(arr) // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>23-</p>
</blockquote>
<p>array.reduce(callbackfn,[initialValue])<br>reduce()方法接收callbackfn函数，而这个函数包含四个参数：</p>
<p>callbackfn(preValue,curValue,index,array){}<br>preValue: 上一次调用回调返回的值!!!!(不是前一个值)或者是提供的初始值（initialValue）<br>curValue: 数组中当前被处理的数组项<br>index: 当前数组项在数组中的索引值<br>array: 调用 reduce()方法的数组</p>
<p>如果 initialValue 在调用 reduce() 时被提供，那么第一个 preValue 等于 initialValue ，并且curValue等于数组中的第一个值；<br>如果initialValue 未被提供，那么preValue 等于数组中的第一个值，curValue等于数组中的第二个值。<br>(可以看看老王模糊查询那个例子。。reduce有点东西的)</p>
<blockquote>
<p>24-</p>
</blockquote>
<p>findIndex(callback[, thisArg])方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>find(callback[, thisArg]) 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>callback接受3个参数(element, index, array)<br>过滤器filter(callback[, thisArg])返回值是一个新的通过测试的元素的集合的数组<br>callback与上同理，return (element &gt;= 10);<br>every(callback[, thisArg])&lt;每一个&gt;方法测试数组的所有元素是否都通过了指定函数的测试，返回一个布尔值。<br>some(callback[, thisArg])&lt;某些&gt;方法测试数组中的某些元素是否通过由提供的函数实现的测试，返回一个布尔值。<br>callback与上同理，return (element &gt;= 10);</p>
<blockquote>
<p>25-includes(searchElement[, fromIndex])</p>
</blockquote>
<p>方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。fromIndex(可选)从该索引处开始查找 searchElement。</p>
<blockquote>
<p>26-eval：返回字符串表达式中的值;unEscape：返回字符串ASCI码;escape：返回字符的编码;parseFloat：返回实数</p>
</blockquote>
<p>在 JavaScript 中有两种机制可以“欺骗”词法作用域：eval(..) 和 with。这些机制的缺点是，它压制了 引擎 在作用域查询上进行编译期优化的能力，因为 引擎 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 将  </p>
<blockquote>
<p>27-isNaN方法：该方法用于检测参数是否为数值型，如果不是，返回true！</p>
</blockquote>
<blockquote>
<p>28-Promise</p>
</blockquote>
<p>Promise构造器的prototype上还有两个方法，分别是then和catch:<br>then 有两个参数(res,rej)都是回调函数 第一个回调函数，在Promise 状态为resolve 执行，第二个在状态为reject执行。<br>catch方法，相当于then(null,reject)的一个变体<br>(要看看promise和async)</p>
<blockquote>
<p>29-有点东西的例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Object(&apos;1&apos;) === 1 //false</span><br><span class="line">new Number(&apos;1&apos;) === 1 //false</span><br><span class="line">new Boolean() === false //false</span><br><span class="line">//以上换成双等号都为true</span><br><span class="line"></span><br><span class="line">可以知道new Number(&apos;1&apos;) //Number &#123;1&#125;</span><br><span class="line"></span><br><span class="line">typeof(new Object()) === typeof(null) //true</span><br><span class="line"></span><br><span class="line">不过Number(&quot;1&quot;)===1 //true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>30-关于定时器：(setTimeout是window的一个方法，严格来讲不是JS全局函数)</p>
</blockquote>
<p>window.setTimeout(checkState(), 10000); //立即被调用,作用域为当前<br>window.setTimeout(checkState, 10000); // 10s后被调用,作用域为当前<br>window.setTimeout(“checkState()”, 10000); //10s后被调用 注意和第一个的区别(有引号)作用域为全局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fuc = [1,2,3];</span><br><span class="line">for(var i in fuc)&#123;</span><br><span class="line">  setTimeout(function()&#123;console.log(fuc[i])&#125;,0);</span><br><span class="line">  console.log(fuc[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 3 3 3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里涉及到javascript单线程执行的问题：javascript在浏览器中是单线程执行的，必须在完成当前任务后才执行队列中的下一个任务。另外，对于javascript还维护着一个setTimeout队列，未执行的setTimeout任务就按出现的顺序放到setTimeout队列，等待普通的任务队列中的任务执行完才开始按顺序执行积累在setTimeout中的任务。所以设置0可以使同步代码转异步代码，这是为了手动调配优先级不高的代码靠后执行。</p>
</li>
<li><p>注意：</p>
</li>
</ul>
<ol>
<li>setTimeout中的延迟执行代码中的this永远都指向window</li>
<li>setTimeout(this.method, time)这种形式中的this，即上文中提到的第一个this，是根据上下文来判断的，默认为全局作用域，但不一定总是处于全局下，具体问题具体分析。</li>
<li>setTimeout(匿名函数, time)这种形式下，匿名函数中的变量也需要根据上下文来判断，具体问题具体分析</li>
</ol>
<blockquote>
<p>31-js函数调用与声明:</p>
</blockquote>
<p>加括号为调用该函数，返回值为函数返回值;<br>不加括号可认为是查看函数完整信息，即查看整个函数体，返回值即整个函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as.onclick = test等于as.addEventListener(&quot;click&quot;,test)//把test指向的函数值赋值给onclick属性</span><br><span class="line">as.onclick = test()等于as.addEventListener(&quot;click&quot;，test());//把test函数的执行结果赋值给onclick属性，所以他马上执行了。。</span><br></pre></td></tr></table></figure>
<p>而声明函数的2种形式：<br>function foo(){…} //函数声明<br>var foo=function(){…}性质等于var foo=function bar(){…} //函数表达式</p>
<blockquote>
<p>32-操纵元素CSS:</p>
</blockquote>
<p>var a =document.querySelector(‘xxx’);<br>a.style.cssText(获取css所有样式);<br>a.style.cssText+=”margin:90px;color:red”(直接添加css样式)或者a.style.color=”green”(单个单个添加css样式)<br>或者a.setAttribute(‘class’, ‘xxxclass名’)(直接赋给该元素class名的样式)<br>获取该元素的class名：a.className(添加xx名的class样式:a.className+=”xx”)<br>获取该元素的父节点：a.parentElement<br>获取所有子节点:a.childNodes(包含了标签与标签之间的空格行，称为#text，最好用nodeName区别)<br>获取标签:a.nodeName</p>
<p>创建元素/文本节点:<br>var al=document.createElement(“span”)<br>var bl=document.createTextNode(“Water”)<br>al.appendChild(bl)</p>
<blockquote>
<p>33-强制类型转换:</p>
</blockquote>
<p>强制转换为Boolean 用 !!<br>var bool = !!”c”;<br>console.log(typeof bool); // boolean<br>强制转换为Number 用 +<br>var num = +”1234”;<br>console.log(typeof num); // number<br>强制转换为String 用 “”+<br>var str = “”+ 1234;<br>console.log(typeof str); // string</p>
<p>大佬的一句代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(!(~+[])+&#123;&#125;)[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]+(&#123;&#125;+[])[[~!+[]]*~+[]]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>34-用match过滤字符串数组的字母:str.filter(x =&gt; x.match(/[a-zA-Z]/))</p>
</blockquote>
<blockquote>
<p>35-函数声明会被提升，就像我们看到的。但是函数表达式不会。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line"></span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//准确地解释为:</span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">foo(); // foo() 就是试图调用一个 undefined 值，这是一个 TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">  var bar = ...self...</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们各自的作用域顶部，这就是我们所说的提升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo(); // &quot;b&quot;</span><br><span class="line"></span><br><span class="line">var a = true;</span><br><span class="line">if (a) &#123;</span><br><span class="line">   function foo() &#123; console.log( &quot;a&quot; ); &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">   function foo() &#123; console.log( &quot;b&quot; ); &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这段代码说明了声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>36-undefined和null与任何有意义的值比较返回的都是false，但是null与undefined之间互相比较返回的是true!!</p>
</blockquote>
<blockquote>
<p>37-关于typeof和instanceof:</p>
</blockquote>
<p>a instanceof Object //大写<br>typeof a == “object”  //小写且有引号<br>（undefined, number, string , boolean）属于简单的值类型，不是对象。<br>（null、函数、数组、对象）都是引用类型(具有对象特性，即1 自由扩展属性 2 __proto__属性值指向它的构造函数的”prototype”属性值，除了null)</p>
<ul>
<li>值类型（undefined等）的类型判断用typeof(但是typeof可以判断出function)，引用类型的类型判断用instanceof</li>
<li>引用类型的变量其实也是基本类型，而引用指向的对象本身才是引用类型。null不指向任何变量，它是一个常量，所以说是基本类型。但是null要用instanceof来判断！！</li>
<li>注意一下typeof null//object</li>
</ul>
<blockquote>
<p>38-变量重复声明也不会错，js里有声明提前，如果两次声明都有赋值，如：var a=10; var a=100; 则变量a的值是100;若var a=10; var a; 则变量a的值是10;第二次的var a;没什么用</p>
</blockquote>
<blockquote>
<p>39-JSON是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。</p>
</blockquote>
<blockquote>
<p>40-js线程：</p>
</blockquote>
<p>JS本身是单线程的，例如setTimeout、setInterval，这类函数是由运行环境提供的，本身不属于JS的，调用这些函数浏览器会单开一个和JS并行的定时线程，因此JS可以去处理后续的任务，当时间到达后上述函数中的回调函数会被放到事件队列中，等待JS主线程取出来执行。<br>另外nodeJS提供的fs.readFile()等也是单开了一个新的线程</p>
<blockquote>
<p>41- <img src="/images/js1.png" alt=""></p>
</blockquote>
<blockquote>
<p>42-document.write 只能重绘整个页面 而innerHTML 可以重绘页面的一部分</p>
</blockquote>
<blockquote>
<p>43-在js里面添加的属性名使用驼峰法，在css里面使用连接线如</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; onmouseover=&quot;this.style.fontSize=&apos;30px&apos;&quot;&gt;注册&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>44-Element.classList</p>
</blockquote>
<p>Element.classList 是一个只读属性，返回一个元素的类属性的实时DOMTokenList集合:<br>add( String [, String] )<br>添加指定的类名。如果这些类已经存在于元素的属性中，那么它们将被忽略。<br>remove( String [,String] )<br>删除指定的类名。<br>item ( Number )<br>返回类名在元素中的索引值。索引值从 0 开始<br>toggle ( String [, force] )<br>当只有一个参数时,即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。<br>当存在第二个参数时,是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它<br>contains( String )<br>检查元素的类属性中是否存在指定的类值,返回布尔值</p>
<blockquote>
<p>45-this和event.target</p>
</blockquote>
<p>每次触发DOM事件时会产生一个事件对象（也称event对象），此处的参数e接收事件对象。而事件对象也有很多属性和方法，其中target属性是获取触发事件对象的目标，也就是绑定事件的元素，e.target表示该DOM元素，然后在获取其相应的属性值。<br>this和event.target的区别：<br>js中事件是会冒泡的，所以this是可以变化的，this只能在执行时才能确认值，定义时无法确认，但event.target不会变化，它永远是直接接受事件的目标DOM元素;<br>.this和event.target都是dom对象</p>
<blockquote>
<p>46-当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p>
</blockquote>
<blockquote>
<p>47-数组的操作(如sort(),reverse(),push(),pop(),shift(),unshift()都会将原数组改变)</p>
</blockquote>
<p>var arr1 = arr.reverse();<br>或者var arr1 = arr;<br>    var arr2 = arr.reverse();//这样操作arr、arr1和arr2都是倒序后的结果 </p>
<blockquote>
<p>48-hasOwnProperty和isPrototypeOf</p>
</blockquote>
<p>hasOwnProperty：区分一个属性到底是基本的还是从原型中找到的,是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。<br>isPrototypeOf:是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false</p>
<blockquote>
<p>49-node.insertBefore(newnode[,existingnode])</p>
</blockquote>
<p>newnode: Node 对象(必需)。需要插入的节点对象。<br>existingnode: Node object(可选)。在其之前 插入新节点的子节点。如果未规定，则 insertBefore 方法会在结尾插入newnode。(例:node.childNodes[0],表示在node.childNodes[0]这个子节点之前插入)</p>
<blockquote>
<p>50-ie9以下不支持addEventListener来绑定事件,只支持的是attachEvent，不同之处是第二个参数事件名要多加个”on”，比如”onclick”，而且他的this指向的是window，在使用的时候需要改变this指向</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Event = &#123;&#125;;</span><br><span class="line">Event.addEvents = function(target,eventType,handle)&#123;</span><br><span class="line">    if(document.addEventListener)&#123;</span><br><span class="line">        Event.addEvents = function(target,eventType,handle)&#123;</span><br><span class="line">            target.addEventListener(eventType,handle,false);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Event.addEvents = function(target,eventType,handle)&#123;</span><br><span class="line">            target.attachEvent(&apos;on&apos;+eventType,function()&#123;</span><br><span class="line">                handle.call(target,arguments);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Event.addEvents(target,eventType,handle);</span><br><span class="line">&#125;;</span><br><span class="line">//调用方法：</span><br><span class="line">Event.addEvents(document,&quot;click&quot;,function()&#123;</span><br><span class="line">        alert(ok)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>51-布尔类型与其它任何类型进行比较，布尔类型将会转换为number类型。</p>
</blockquote>
<p>Number([])返回0<br>Number转换类型的参数如果为对象返回的就是NaN(Number({})返回的就是NaN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 42;</span><br><span class="line">var b = &quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">a &lt; b;    // false</span><br><span class="line">a &gt; b;    // false</span><br><span class="line">a == b;   // false</span><br></pre></td></tr></table></figure>
<p>因为在&lt;和&gt;的比较中，值b被强制转换为了“非法的数字值”，而且语言规范说NaN既不大于其他值，也不小于其他值。</p>
<blockquote>
<p>52-jq推荐”==”与”===”写法：</p>
</blockquote>
<ul>
<li>a==null等于a===null||a===undefined（需要分辨出null和undefined时）</li>
<li>其他最好全部用===</li>
</ul>
<blockquote>
<p>53-如何理解JSON</p>
</blockquote>
<ul>
<li>js的内置对象,有2个API：JSON.stringify和JSON.parse</li>
<li>也是一种数据格式</li>
</ul>
<blockquote>
<p>54-bind只能添加在函数表达式后，不能用于函数声明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fn1 = function (name)&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;.bind(&#123;x:100&#125;)//将this指向bind里的值</span><br><span class="line">fn1(&apos;lsj&apos;);</span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"></span><br><span class="line">function fn2(name,age)&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fn2.call(&#123;x:100&#125;,&apos;lsj&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>55-js event里面的target获取到它是父元素的第几个=&gt;[].indexOf.call(e.target.parentNode.children,e.target)</p>
</blockquote>
<blockquote>
<p>56-js 使事件失效： return false 或 e.preventDefault();</p>
</blockquote>
<blockquote>
<p>57-判断两个对象相等JSON.stringify(obj)==JSON.stringify(obj);//true</p>
</blockquote>
<blockquote>
<p>58-扩展console.log</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;foo&quot;);输出 1:foo</span><br><span class="line">    console.log(&quot;bar&quot;);输出 2:foo</span><br><span class="line">    let flag = 1;</span><br><span class="line">    console.log = (function (log)&#123;</span><br><span class="line">        return function (str)&#123;</span><br><span class="line">            log.call(console,`$&#123;flag++&#125;:$&#123;str&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(console.log)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>59-实现extend</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function extend() &#123;</span><br><span class="line">    var name, options;</span><br><span class="line">    var length = arguments.length;</span><br><span class="line">    var target = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        options = arguments[i];</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            for (name in options) &#123;</span><br><span class="line">              if (options[name] !== undefined)&#123;             </span><br><span class="line">                    target[name] = options[name];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>60-匿名函数</p>
</blockquote>
<p>创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。括号是表达式，是表达式就有返回值，所以可以在后面加一对括号让它们执行.</p>
<ol>
<li>区别:<br>(function {// code})是表达式, function {// code}是函数声明.</li>
<li>js”预编译”的特点:<br>js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.</li>
<li>当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错;<br>当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.</li>
</ol>
<blockquote>
<p>61-Object.entries()</p>
</blockquote>
<p>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于for-in循环也枚举原型链中的属性）</p>
<h2 id="html-css类："><a href="#html-css类：" class="headerlink" title="html+css类："></a>html+css类：</h2><blockquote>
<p>1-text-transform</p>
</blockquote>
<p>text-transform: capitalize;//是所有英文单词以大写字母开头<br>text-transform: lowercase//是所有英文单词中无大写字母</p>
<blockquote>
<p>2-visibility:hidden;不产生reflow和repaint(回流与重绘)</p>
</blockquote>
<blockquote>
<p>3-datalist标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值</p>
</blockquote>
<blockquote>
<p>4-在一个web表单中, HTML元素 optgroup 会创建包含在一个 select 元素中的一组选项</p>
</blockquote>
<blockquote>
<p>5-</p>
</blockquote>
<p>enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。<br>属性值<br>application/x-www-form-urlencoded<br>在发送前编码所有字符（默认）<br>multipart/form-data<br>不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值。<br>text/plain<br>空格转换为 “+” 加号，但不对特殊字符编码。</p>
<blockquote>
<p>6-readonly和disabled</p>
</blockquote>
<p>disabled指当 input 元素加载时禁用此元素。input内容不会随着表单提交<br>readonly规定输入字段为只读。input内容会随着表单提交。而且只针对input(text/password)和textarea有效<br>无论设置readonly还是disabled，通过js脚本都能更改input的value<br>而:disabled伪类指定一个表单元素处于不可用状态。处于不可用状态的元素不可以被选择、选中、激活或者获得焦点。</p>
<p>xx:enabled 选择器匹配每个已启用的元素/ xx:disabled被禁用的 input 元素 （大多用在表单元素上）</p>
<blockquote>
<p>7-span select 是内联(行内)元素 img input 是内联块元素 form 是块级元素</p>
</blockquote>
<blockquote>
<p>8-label标签只有两个属性for（规定label绑定到哪个表单元素）;form（规定label字段所属的一个或多个表单;没有id属性）</p>
</blockquote>
<blockquote>
<p>9-html文档加载是从上到下加载，只与标签的上下顺序有关，与标签选用无关</p>
</blockquote>
<blockquote>
<p>10-在HTML body部分中的JavaScripts会在页面加载的时候被执行。<br>在HTML head部分中的JavaScripts会在被调用的时候才执行。<br>！</p>
</blockquote>
<blockquote>
<p>11-display:</p>
</blockquote>
<p>inherit 规定应该从父元素继承 display 属性的值。<br>inline  默认。此元素会被显示为内联元素，元素前后没有换行符。<br>inline-block  行内块元素。（像行内元素一样显示，但其内容象块类型元素一样显示）<br>block 此元素将显示为块级元素，此元素前后会带有换行符。</p>
<blockquote>
<p>13-link和@import:</p>
</blockquote>
<p>link属于HTML标签，而@import是CSS提供的;<br>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
<blockquote>
<p>14-css伪元素</p>
</blockquote>
<p>:after 选择器在被选元素的内容后面插入内容。请使用content属性来指定要插入的内容</p>
<blockquote>
<p>15-BFC:</p>
</blockquote>
<p>块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个 BFC 中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的 margin 会发生折叠。</p>
<blockquote>
<p>16-CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中</p>
</blockquote>
<blockquote>
<p>17-事实上SEO(搜索引擎优化)最有效的一种办法，就是对网页的HTML结构进行重构，实质上就是语义化。</p>
</blockquote>
<blockquote>
<p>18-Doctype文档类型可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
</blockquote>
<blockquote>
<p>19-IE8以下浏览器的盒模型中定义的元素的宽高包括内边距和边框</p>
</blockquote>
<blockquote>
<p>20-H5新增技术：webworker, websocket, Geolocation</p>
</blockquote>
<blockquote>
<p>21-css中颜色，文字，字体间距行高对齐方式，和列表的样式可以继承可以继承可以继承；</p>
</blockquote>
<blockquote>
<p>22-transforms是当元素从一种样式变换为另一种样式时为元素添加效果的属性</p>
</blockquote>
<blockquote>
<p>23-DHTML 的动态样式的作用是使网页作者改变内容的外部特征而不强制用户再次下载全部内容</p>
</blockquote>
<blockquote>
<p>24-figure以及figcaption标签：</p>
</blockquote>
<p>figure标签，HTML5语义化标签<br>用于规定独立的流内容（图像、图表、照片、代码等等）<br>figcaption标签，HTML5语义化标签<br>与figure配套使用，用于标签定义figure元素的标题</p>
<blockquote>
<p>25-transform属性：</p>
</blockquote>
<p>transform-origin控制旋转的中心点，默认值50% 50%;<br>translate（水平）– transform:translate(10px,10px);translateX(-50%);<br>rotate（旋转）– transform:rotate(90deg);<br>scale（缩放）– transform:scale(0.5,0.5);<br>skew（斜切）– transform:skew(50deg,0deg);</p>
<blockquote>
<p>26-transition属性:</p>
</blockquote>
<p>属性都可单独写：transition-…..<br>property: 过渡属性（必写值）,值为all时该大括号的所有类型都执行transition中的值<br>duration：动画持续时间 （必写值）<br>timing-function：liner-匀速\ease-in-减速\ease-out-加速\ease-in-out-先加速再减速\cubic-bezier-三次贝塞尔曲线<br>delay：检索或设置对象延迟过渡的时间</p>
<blockquote>
<p>27-媒体查询可以备用在css中的@media 和@import 规则上 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media sreen and (width:800px)&#123; 样式 &#125;</span><br><span class="line">@import url(example.css) screen and (width:800px)</span><br><span class="line">&lt;link media=&quot;screen and (width:800px)&quot; rel=&quot;stylesheet&quot; href=&quot;example.css&quot; /&gt;0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>28-</p>
</blockquote>
<p>onBlur:当失去输入焦点后产生该事件<br>onFocus:当输入获得焦点后，产生该文件<br>onchange:当文字值改变时，产生该事件</p>
<blockquote>
<p>29-@charset “utf-8”</p>
</blockquote>
<p>因为纯英文的文档不管是utf-8编码还是ansi编码都是完全一样的。但是如果含有中文（哪怕只有一个字或符号），也必须声明（当然不声明的话会默认为ansi编码）。</p>
<blockquote>
<p>30-浏览器图片请求:</p>
</blockquote>
<ol>
<li>只要是img src引用的都会请求；</li>
<li>background: url()所属样式如果挂靠在某个元素上，就一定会请求；单独写了这么一个样式并不请求。</li>
</ol>
<blockquote>
<p>31-background-attachment:</p>
</blockquote>
<p>scroll:是默认值，背景图像会随着页面其余部分的滚动而移动。<br>fixed:当页面的其余部分滚动时，背景图像不会移动。<br>inherit:规定应该从父元素继承background-attachment属性的设置。</p>
<blockquote>
<p>32-<br>background-origin:属性规定 background-position 属性相对于什么位置来定位。(padding-box|border-box|content-box)<br>background-position :属性设置背景图像的起始位置。默认值(0% 0%)<br>background-clip:属性规定背景的绘制区域。</p>
</blockquote>
<blockquote>
<p>33-要运用css3动画，需要运用@keyframes规则和animation属性</p>
</blockquote>
<blockquote>
<p>34-法则：但凡是用到clientX,clientY的时候，一定用到scrollLeft,scrollTop,不然几乎是一定会出问题的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">封装scrollTop和scrollLeft</span><br><span class="line">因为经常用到，写起来麻烦，封装成库</span><br><span class="line">function getPos(e) &#123;</span><br><span class="line">    var st = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">    var sl = document.documentElement.scrollLeft || document.body.scrollLeft;</span><br><span class="line">    return &#123;x:e.clientX+sl, y:e.clientY+st&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>35-我们平常会使用left和top属性来修改元素的位置，但left和top会触发重布局，取而代之的更好方法是使用translate，这个不会触发重布局</p>
</blockquote>
<blockquote>
<p>36-用window.getComputedStyle(elem).getPropertyValue(“transform”)可以得到实际的transform值</p>
</blockquote>
<blockquote>
<p>37-clip: rect(0px 200px 100px 0px);  //上右下左坐标,只适用于absolute</p>
</blockquote>
<blockquote>
<p>38-文字超出…表示：</p>
</blockquote>
<p>white-space: nowrap; //文本不会换行,直到遇到br标签为止<br>overflow: hidden;<br>text-overflow: ellipsis;</p>
<blockquote>
<p>39-中文超出了会默认换行，但是对于英文或者数字来说超出不换行，要加上</p>
</blockquote>
<p>word-wrap: break-word;<br>word-break: break-all;(normal(默认规则)|break-all(允许在单词内换行)|keep-all(只能在半角空格或连字符处换行))</p>
<blockquote>
<p>40-@keyframe</p>
</blockquote>
<p>语法：@keyframes keyframesname {keyframes-selector {css-styles;}}keyframesname是动画名字；keyframes-selector帧选择器，用百分比定义，0%-100%，与from-to等价，作用是定义不同时间段的不同样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>41-animation</p>
</blockquote>
<p>animation-name：keyframes名称<br>animation-duration： 指定完成动画所花费的时间，单位为秒（s）或毫秒（ms）<br>animation-timing-function： 指定动画的速度曲线<br>animation-delay：指定在动画开始之间的延迟，单位为秒（s）或毫秒（ms），若为负值表示跳过前几秒执行<br>animation-iteration-count： 指定动画应该播放的次数，默认为1次，自己也可以定义播放次数，以及无限次infinite；<br>animation-direction：指定是否应该轮流反向播放动画。(normal：默认值，动画按正常播放)||(reverse：动画反向播放)<br>…还有一些参数不列举了</p>
<blockquote>
<p>42-“display:table;”的CSS声明能够让一个HTML元素和它的子节点像table元素一样。</p>
</blockquote>
<p>使用基于表格的CSS布局，使我们能够轻松定义一个单元格的边界、背景等样式(类似table此元素会作为块级表格来显示，表格前后带有换行符)，而不会产生因为使用了table那样的制表标签所导致的语义化问题</p>
<blockquote>
<p>42-轮播图</p>
</blockquote>
<p>无缝滚动：首尾多加2张图（判断left方式检测是否最后一张）<br>匀速运动（还要用到定时器）：匀速动画的原理是 当前的位置 + 速度  即 offsetLeft + speed<br>基本实现：<a href="https://www.cnblogs.com/LIUYANZUO/p/5679753.html" target="_blank" rel="noopener">https://www.cnblogs.com/LIUYANZUO/p/5679753.html</a></p>
<blockquote>
<p>43-需要注意的地方</p>
</blockquote>
<ol>
<li>position：absolute中的 left，top的默认值并不是0；</li>
<li>没有设置left、top时，left和top的默认值将使元素的位置和“原来的位置”一样。</li>
</ol>
<blockquote>
<p>44-</p>
</blockquote>
<p>box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；<br>box-sizing:border-box时，将采用怪异模式解析计算；</p>
<blockquote>
<p>45-移动端1px像素变粗的问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这句话定义了本页面的viewport的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的</p>
<p>viewport的设置和屏幕物理分辨率是按比例而不是相同的. 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长</p>
<p>可以通过transform: scale(0.5)放在伪类里解决</p>
<h2 id="http类："><a href="#http类：" class="headerlink" title="http类："></a>http类：</h2><blockquote>
<p>1-Cookie和Storage</p>
</blockquote>
<p>Cookie的本身作用是与服务器进行交互(cookie是跟域名绑定的,cookie是不能跨域访问的，但是在二级域名是可以共享cookie的)，作为HTTP规范的一部分而存在 ，但是它有本地存储的功能，于是就被借用存储(document.cookie=…获取和修改)，而Web Storage仅仅是为了在本地“存储”数据而生,它是为了更大容量存储设计的，最大容量5M（因为不用在交互中发送）</p>
<blockquote>
<p>2-sessionStorage和localStorage</p>
</blockquote>
<p>浏览器本地存储:html5中的WebStorage包括了两种存储方式：sessionStorage和localStorage;<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。（ios safari隐藏模式下，localStorage.getItem会报错）</p>
<blockquote>
<p>3-(js)解释语言特性：1.非独立2.效率低</p>
</blockquote>
<blockquote>
<p>4-调用 localstorge、cookies 等本地存储方式可以实现浏览器内多个标签页之间的通信</p>
</blockquote>
<blockquote>
<p>5-XMLHttpRequest中<br>status属性返回状态码，为一个数字。<br>statusText属性返回状态码以及描述，字符串。<br>并没有statusCode…. </p>
</blockquote>
<blockquote>
<p>6-webSocket 如何兼容低浏览器？</p>
</blockquote>
<p>Adobe Flash Socket<br>ActiveX HTMLFile (IE)<br>基于 multipart 编码发送 XHR<br>基于长轮询的 XHR</p>
<blockquote>
<p>7-</p>
</blockquote>
<p>BOM(Browser Obeject model)：<br>Navigator：提供有关浏览器的信息(navigator.userAgent可以检测浏览器类型，用includes)<br>Window：Window对象处于对象层次的最顶层，它提供了处理Navagator窗口的方法和属性<br>Location：提供了与当前打开的URL一起工作的方法和属性，是一个静态的对象<br>History：包含了浏览器窗口访问过的 URL<br>Screen：包含客户端显示屏的信息</p>
<p>Document(代表整个HTML文档可被用来访问页面中的所有元素)：包含与文档元素一起工作的对象，它将这些元素封装起来供编程人员使用</p>
<blockquote>
<p>8-Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一</p>
</blockquote>
<blockquote>
<p>9-在node中的全局变量是global,浏览器的全局变量是window。可以通过该全局变量是否定义来判断宿主环境</p>
</blockquote>
<blockquote>
<p>10-window</p>
</blockquote>
<p>_blank:在新窗口打开 _self:在当前窗口打开 _parent:在父级窗口打开 _top:在最顶级窗口打开</p>
<blockquote>
<p>11-并行下载多少个资源</p>
</blockquote>
<p>IE62个并发,iE7升级之后的6个并发,之后版本也是6个;<br>Firefox,chrome也是6个</p>
<blockquote>
<p>12-HTML5新增的API</p>
</blockquote>
<p>history.pushState(data, title [, url])：往历史记录堆栈顶部添加一条记录； data会在onpopstate事件触发时作为<br>参数传递过去；title为页面标题，当前所有浏览器都会 忽略此参数；url为页面地址，可选，缺省为当前页地址；<br>history.replaceState(data, title [, url]) ：更改当前的历史记录，参数同上；(可以实现后退不了)</p>
<blockquote>
<p>13-改变浏览器地址而不向服务器发出请求有两种方式: </p>
</blockquote>
<ol>
<li>在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航 </li>
<li>使用H5的window.history功能，使用URL的Hash来模拟一个完整的URL。</li>
</ol>
<blockquote>
<p>14-从顶到下，TCP/IP协议可以分为5层，依次是应用层、传输层、网络层、数据链路层和物理层</p>
</blockquote>
<blockquote>
<p>15-单线程、多线程的区别</p>
</blockquote>
<p>单线程程序：只有一个线程，代码顺序执行，容易出现代码阻塞（页面假死）<br>多线程程序：有多个线程，线程间独立运行，能有效地避免代码阻塞，并且提高程序的运行性能</p>
<blockquote>
<p>16-在HTTP(应用层) 和TCP(传输层)之间插入一个SSL/TLS协议(安全套接字层), 就是HTTPS.<br>(HTTP+加密+认证+完整性保护=HTTPS)</p>
</blockquote>
<p>HTTP:HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。</p>
<blockquote>
<p>17-RestAPI一句话描述：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作</p>
</blockquote>
<ol>
<li>REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）</li>
<li>Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心</li>
<li>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转</li>
</ol>
<blockquote>
<p>18-进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p>
</blockquote>
<blockquote>
<p>19-Web缓存有：1.数据库缓存 2.代理服务器缓存（共享缓存） 3.CDN缓存 4.浏览器缓存</p>
</blockquote>
<blockquote>
<p>20-描述并发和并行：</p>
</blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。（所以并行无法预测谁先结束）<br>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。<br>所以它们最关键的点就是：是否是『同时』<br>在这些并发“进程”之间进行某种形式的互动协调通常是有必要的，比如保证顺序或防止“竞合状态”。这些“进程”还可以 协作：通过将它们自己打断为小的代码块儿来允许其他“进程”穿插。</p>
<h2 id="sql类"><a href="#sql类" class="headerlink" title="sql类:"></a>sql类:</h2><p>“空值” 和”NULL”的概念：<br>1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br>2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>
<h1 id="三-JS专题问题："><a href="#三-JS专题问题：" class="headerlink" title="三.JS专题问题："></a>三.JS专题问题：</h1><h2 id="1-setTimeout"><a href="#1-setTimeout" class="headerlink" title="1(setTimeout)"></a>1(setTimeout)</h2><p>setTimeout里面的this是指向window，保存当前对象this为别名that 和 通过闭包得到当前作用域，<br>以访问保存好的对象that;当对象方法里面多层嵌套函数或者setTimeout,setInterval等方法丢失this<br>（也就是this不指向当前对象而是window）,所以在this指向正确的作用域保存var that = this就变得很实用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function obj() &#123; </span><br><span class="line">this.fn = function() &#123; </span><br><span class="line">var that = this;//保存当前对象this </span><br><span class="line">alert(&quot;ok&quot;); </span><br><span class="line">setTimeout(function()&#123; </span><br><span class="line">that.fn(); </span><br><span class="line">&#125;, 1000);//通过闭包得到当前作用域，好访问保存好的对象that </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">var o = new obj(); </span><br><span class="line">o.fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="2-js的map和foreach原来不能改变当前索引的值："><a href="#2-js的map和foreach原来不能改变当前索引的值：" class="headerlink" title="2.js的map和foreach原来不能改变当前索引的值："></a>2.js的map和foreach原来不能改变当前索引的值：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f (arr)&#123;arr.map(function(e,i)&#123;console.log(i);i--&#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>结果当然还是1234…</p>
<h2 id="3-推荐在循环对象属性的时候，使用for…in-在遍历数组的时候的时候使用for…of。"><a href="#3-推荐在循环对象属性的时候，使用for…in-在遍历数组的时候的时候使用for…of。" class="headerlink" title="3.推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。"></a>3.推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。</h2><p>for…in循环出的是key，for…of循环出的是value<br>注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足<br>for…of不能循环普通的对象，需要通过和Object.keys()搭配使用<br>假设我们要遍历一个数组的valuelet aArray = [‘a’,123,{a:’1’,b:’2’}]<br>使用for…in循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let index in aArray)&#123;</span><br><span class="line">    console.log(`$&#123;aArray[index]&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用for…of循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var value of aArray)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咋一看好像好像只是写法不一样而已，那为什么说for…of修复了for…in的缺陷和不足。<br>假设我们往数组添加一个属性name:<br>aArray.name = ‘demo’,再分别查看上面写的两个循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let index in aArray)&#123;</span><br><span class="line">    console.log(`$&#123;aArray[index]&#125;`); //Notice!!aArray.name也被循环出来了</span><br><span class="line">&#125;</span><br><span class="line">for(var value of aArray)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，作用于数组的for-in循环除了遍历数组元素以外,还会遍历自定义属性。<br>for…of循环不会循环对象的key，只会循环出数组的value，因此for…of不能循环遍历普通对象,对普通对象的属性遍历推荐使用for…in<br>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var student=&#123;</span><br><span class="line">    name:&apos;wujunchuan&apos;,</span><br><span class="line">    age:22,</span><br><span class="line">    locate:&#123;</span><br><span class="line">    country:&apos;china&apos;,</span><br><span class="line">    city:&apos;xiamen&apos;,</span><br><span class="line">    school:&apos;XMUT&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var key of Object.keys(student))&#123;</span><br><span class="line">    //使用Object.keys()方法获取对象key的数组</span><br><span class="line">    console.log(key+&quot;: &quot;+student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-理解一下call与arguments"><a href="#4-理解一下call与arguments" class="headerlink" title="4.理解一下call与arguments~"></a>4.理解一下call与arguments~</h2><p>-apply/call：<br>数组：fn.apply(this,arr)/对象： fn.call(obj)/fn.apply(obj,[])&lt;~给apply传递null，“”空字符串，默认都是this&gt;<br>bind返回的是一个新的函数,call与bind的参数是列表,apply是数组<br>bind会绑定this，后面通过bind或者call再次绑定的时候，就无法修改这个this了</p>
<p>猫吃鱼，狗吃肉，奥特曼打小怪兽。<br>有天狗想吃鱼了<br>猫.吃鱼.call(狗，鱼)<br>狗就吃到鱼了<br>猫成精了，想打怪兽<br>奥特曼.打小怪兽.call(猫，小怪兽)</p>
<blockquote>
<p>实现一个call</p>
</blockquote>
<ul>
<li><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</li>
<li><p>思路：</p>
</li>
</ul>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- var args = Array.prototype.slice.call(arguments,1);</span><br><span class="line">    var result = context.fn.apply(null, args.concat([].slice.call(arguments))); --&gt;</span><br><span class="line">    //这里因为是实现一个call，所以这里用call不太好。。可以用下面这种方法</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var value = 2;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    return &#123;</span><br><span class="line">        value: this.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(null); // 2</span><br><span class="line">console.log(bar.call2(obj, &apos;kevin&apos;, 18));</span><br><span class="line">// 1</span><br><span class="line">// Object &#123;</span><br><span class="line">//    value: 1,</span><br><span class="line">//    name: &apos;kevin&apos;,</span><br><span class="line">//    age: 18</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bind</p>
</blockquote>
<p>bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.num = 9; </span><br><span class="line">var mymodule = &#123;</span><br><span class="line">  num: 81,</span><br><span class="line">  getNum: function() &#123; return this.num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.getNum(); // 81</span><br><span class="line"></span><br><span class="line">var getNum = module.getNum;</span><br><span class="line">getNum(); // 9, 因为在这个例子中，&quot;this&quot;指向全局对象</span><br><span class="line"></span><br><span class="line">// 创建一个&apos;this&apos;绑定到module的函数</span><br><span class="line">var boundGetNum = getNum.bind(module);</span><br><span class="line">boundGetNum(); // 81</span><br></pre></td></tr></table></figure>
<blockquote>
<p>arguments</p>
</blockquote>
<p>-JS 中，两种常见的 “array-like object”（像数组一样的对象）一个是 arguments，一个就是 nodeList.<br>arguments能获得函数对象传入的参数组，类似与一个数组，能够通过length获取参数个数，能通过下标获取该位置的参数，但是它不能使用forEach等方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments) 做的事儿就是：</span><br><span class="line">var temp = Array.from(arguments)</span><br><span class="line">temp.slice()</span><br></pre></td></tr></table></figure>
<p>Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组</p>
<blockquote>
<p>柯里化：</p>
</blockquote>
<p>ES5的话还是原帖比较详细：<a href="http://blog.csdn.net/crystal6918/article/details/77141741" target="_blank" rel="noopener">http://blog.csdn.net/crystal6918/article/details/77141741</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">最简单版本:x = x =&gt; a =&gt; a+x  //x(1)(2)</span><br><span class="line"></span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">     //先获取p函数第一个参数之后的全部参数</span><br><span class="line">     var args = Array.prototype.slice.call(arguments,1);</span><br><span class="line">     //声明result函数</span><br><span class="line">     return function()&#123;</span><br><span class="line">         //使用concat合并两个或多个数组中的元素</span><br><span class="line">         //[]等价于Array.prototype </span><br><span class="line">         return fn.apply(null, args.concat([].slice.call(arguments)));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这样使用：</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry = curry(add, 1, 2);</span><br><span class="line">addCurry() // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add, 1);</span><br><span class="line">addCurry(2) // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add);</span><br><span class="line">addCurry(1, 2) // 3</span><br></pre></td></tr></table></figure>
<h2 id="5-LHS查询和RHS查询"><a href="#5-LHS查询和RHS查询" class="headerlink" title="5.LHS查询和RHS查询"></a>5.LHS查询和RHS查询</h2><blockquote>
<p>RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。</p>
</blockquote>
<blockquote>
<p><strong>LHS查询</strong>:</p>
</blockquote>
<ul>
<li>LHS查询指的是找到变量的容器本身，从而可以对其进行赋值。也就是找到赋值操作的目标。LHS查询的时候会沿着作用域链进行查询，找到的话就会将值赋值给这个变量，如果到达作用域顶端仍然找不到，就会在作用域链顶端创建这个变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=2;相当于var a; a=2;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的a就是一个LHS引用，我们只是想要为2找到一个赋值的目标，而不会去关心这个目标（这里为a）的值是多少什么的。因为var a;也就是已经把a添加到当前作用域了，所以LHS查询a的时候，找到了a，即找到了赋值操作的目标。如果没有var a;那么LHS查询a的时候，就会找不到a，就会在作用域中创建这个变量a。</li>
</ul>
<blockquote>
<p><strong>RHS查询</strong>:</p>
</blockquote>
<ul>
<li>RHS查询就是普通的查询变量的值，即获取变量的值。RHS查询的时候会沿着作用域链进行查询，找到的话就会取得这个值并返回，如果到达作用域顶端仍然找不到，就会抛出错误（比如TypeError、ReferenceError）</li>
</ul>
<p>console.log(a);</p>
<ul>
<li>这里的a就是一个RHS引用，因为console.log需要获取到a的值才能输出a的值。当然这里的console.log也是一个RHS引用，这里对console 对象进行RHS 查询，并且检查得到的值中是否有一个叫作log 的方法。例子中的a因为没有声明过，所以会抛出错误。</li>
</ul>
<blockquote>
<p><strong>综合例子</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function test() &#123;</span><br><span class="line">    a=2;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>例子中的test函数因为没有执行，所以a=2;也就不会执行，也就不会进行LHS查询，自然就没有变量a啦。而console.log（a）中对a进行RHS查询时，沿着作用域链查找，找不到a，所以会抛出错误（ReferenceError）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function test() &#123;</span><br><span class="line">    a=2;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">//当然上面的IIFE（立即执行函数）也可以写成另一种形势，执行结果一样</span><br><span class="line">(function test() &#123;</span><br><span class="line">    a=2;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>在这里括号的作用是立即执行函数，因此赋值语句a=2就会执行，所以会对a沿着作用域链进行LHS查询，LHS查询找不到a，便在作用域链顶端(全局作用域)创建变量a，故console.log（a）中对a进行RHS查询时，沿着作用域链查找就可以在全局作用域中找到a了，也就可以取得a的值了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = a;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = foo( 2 );</span><br></pre></td></tr></table></figure>
<ul>
<li>找出所有的 LHS 查询（有3处！）：<br>c = .., a = 2（隐含的参数赋值）和 b = ..</li>
<li>找出所有的 RHS 查询（有4处！）：<br>foo(2.., = a;, a + .. 和 .. + b</li>
</ul>
<blockquote>
<p><strong>为什么我们区别 LHS 和 RHS 那么重要？</strong>:</p>
</blockquote>
<p>因为在变量还没有被声明（在所有被查询的 作用域中都没找到）的情况下，这两种类型的查询的行为不同。</p>
<h2 id="6-javascript中的异步-macrotask-和-microtask"><a href="#6-javascript中的异步-macrotask-和-microtask" class="headerlink" title="6.javascript中的异步 macrotask 和 microtask"></a>6.javascript中的异步 macrotask 和 microtask</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;main1&apos;);</span><br><span class="line"></span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;process.nextTick1&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;process.nextTick2&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve, reject) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise then&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;main2&apos;);</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">main1</span><br><span class="line">promise</span><br><span class="line">main2</span><br><span class="line">process.nextTick1</span><br><span class="line">promise then</span><br><span class="line">setTimeout</span><br><span class="line">process.nextTick2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>javascript单线程的 Event Loop 里面，事件循环这两个队列会分两步执行：</p>
</blockquote>
<ol>
<li>首先把Macrotask 中的事件放到stack,并执行,执行完毕;</li>
<li>开始执行Microtask队列中的全部任务，执行完毕;(process.nextTick 会优于 Promise执行)</li>
<li>下一个循环，执行下一个task中的任务，重复第二步。</li>
</ol>
<p>Macrotasks一般包括: setTimeout, setInterval, setImmediate, I/O, UI rendering;<br>Microtasks一般包括: process.nextTick, Promises, Object.observe, MutationObserver;<br>需要注意的是js主线程也算macrotask，所以执行完script之后执行promise…</p>
<p>参考链接:<br><a href="https://vvzt.github.io/2018/04/04/macrotask&amp;microtask/" target="_blank" rel="noopener">https://vvzt.github.io/2018/04/04/macrotask&amp;microtask/</a></p>
<h2 id="7-忘记了this就看这个"><a href="#7-忘记了this就看这个" class="headerlink" title="7.忘记了this就看这个"></a>7.忘记了this就看这个</h2><ul>
<li>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</li>
</ul>
<blockquote>
<p><strong>1/</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var test =&#123;</span><br><span class="line">        &apos;a&apos;:1,</span><br><span class="line">        &apos;b&apos;:function()&#123;</span><br><span class="line">            alert(this === test)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var test1 = test;</span><br><span class="line">test1.b();//true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var test =&#123;</span><br><span class="line">        &apos;a&apos;:1,</span><br><span class="line">        &apos;b&apos;:function()&#123;</span><br><span class="line">            alert(this === test)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var test1 = test.b;</span><br><span class="line">test1();//false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2/</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var test = function()&#123;</span><br><span class="line">        var innerTest = function()&#123;</span><br><span class="line">            alert(this === window);</span><br><span class="line"></span><br><span class="line">            var innerTest1 = function()&#123;</span><br><span class="line">                alert(this === window);</span><br><span class="line">            &#125;</span><br><span class="line">            innerTest1();</span><br><span class="line">        &#125;</span><br><span class="line">        innerTest();</span><br><span class="line">    &#125;</span><br><span class="line">test();//true true</span><br></pre></td></tr></table></figure>
<p>其实这种函数都是’window’对象调用的，及时你嵌套一千层，调用各个函数的都是’window’对象</p>
<blockquote>
<p><strong>3/</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var test = function()&#123;</span><br><span class="line">        alert(this === window);</span><br><span class="line">    &#125;</span><br><span class="line">var test1 = &#123;</span><br><span class="line">&#125;</span><br><span class="line">test.apply(test1);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>该函数的作用就是”调用一个对象的一个方法，以另一个对象替换当前对象”所以了’window’ 对象已经被替代为’test1’，自然为’false’了</p>
</li>
<li><p>另外注意,闭包当中,this是指向window的，也就是说</p>
</li>
</ul>
<ol>
<li>setTimeout中的延迟执行代码中的this永远都指向window</li>
<li>setTimeout(this.method, time)这种形式中的this，即上文中提到的第一个this，是根据上下文来判断的，默认为全局作用域，但不一定总是处于全局下，具体问题具体分析。</li>
<li>setTimeout(匿名函数, time)这种形式下，匿名函数中的变量也需要根据上下文来判断，具体问题具体分析</li>
</ol>
<h2 id="8-事件代理或事件委托："><a href="#8-事件代理或事件委托：" class="headerlink" title="8.事件代理或事件委托："></a>8.事件代理或事件委托：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">            var oBtn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">            var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">            var aLi = oUl.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">            var num = 4;</span><br><span class="line">            </span><br><span class="line">            //事件委托，添加的子元素也有事件</span><br><span class="line">            addmouseover = function(ev)&#123;</span><br><span class="line">                var ev = ev || window.event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">                    target.style.background = &quot;red&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">            oUl.onmouseout = function(ev)&#123;</span><br><span class="line">                var ev = ev || window.event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">                    target.style.background = &quot;#fff&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            //添加新节点</span><br><span class="line">            oBtn.onclick = function()&#123;</span><br><span class="line">                num++;</span><br><span class="line">                var oLi = document.createElement(&apos;li&apos;);</span><br><span class="line">                oLi.innerHTML = 111*num;</span><br><span class="line">                oUl.appendChild(oLi);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">//-------------------------------------------</span><br><span class="line">  app.addEventListener(&apos;click&apos;, function(e) &#123;</span><br><span class="line">    if (e.target &amp;&amp; e.target.nodeName === &apos;LI&apos;) &#123;</span><br><span class="line">      let item = e.target;</span><br><span class="line">      alert(&apos;you clicked on item: &apos; + item.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//e.target能告诉你点击是哪里触发的</span><br><span class="line">//-------------------------------------------自己完善一个绑定事件函数</span><br><span class="line"></span><br><span class="line">function bindEvent(elem,type,selector,fn)&#123;</span><br><span class="line">  if(fn==null)&#123;</span><br><span class="line">    fn=selector;</span><br><span class="line">    selector=null;</span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type,function(e)&#123;</span><br><span class="line">    var target;</span><br><span class="line">    if(selector)&#123;</span><br><span class="line">      //代理</span><br><span class="line">      target = e.target;</span><br><span class="line">      if(target.matches(selector))&#123;</span><br><span class="line">        fn.call(target,e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//bindEvent()里的fn中的参数要加this..</span><br></pre></td></tr></table></figure>
<p>总结：<br>那什么样的事件可以用事件委托，什么样的事件不可以用呢？<br>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。<br>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。<br>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<p>取消冒泡：e.cancelBubble = true;//旧ie的方法<br>阻止冒泡：e.stopPropatation();</p>
<p>源链接：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a></p>
<p>eg:<br>tagName只能用在元素节点上，而nodeName可以用在任何节点上，可以说nodeName涵盖了tagName，并且具有更多的功能，因此建议总是使用nodeName<br>toLowerCase() 方法用于把字符串转换为小写。</p>
<p>querySelectorAll 的返回值是一个静态的 NodeList 对象，<br>而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。</p>
<h2 id="9-经典闭包题看一下"><a href="#9-经典闭包题看一下" class="headerlink" title="9.经典闭包题看一下"></a>9.经典闭包题看一下</h2><p>—循环里包含匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function box() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        arr[i] = function () &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = box();                              //得到函数数组</span><br><span class="line">alert(b.length);                                //得到函数集合长度</span><br><span class="line">for (var i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">    alert(b[i]());                          //输出每个函数的值，都是最后一个值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子输出的结果都是5，作用域链的机制导致一个问题，<strong>在循环中里的匿名函数取得的任何变量都是最后一个值</strong>，也就是循环后得到的最大的i值。因为b[i]调用的是匿名函数，<strong>匿名函数并没有自我执行</strong>，等到调用的时候，box()已执行完毕，i早已变成5，所以最终的结果就是5个5。</p>
<p>—循环里包含匿名函数-改1，自我执行匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function box() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        arr[i] = (function (num) &#123;          //自我执行</span><br><span class="line">            return num;</span><br><span class="line">        &#125;)(i);                          //并且传参</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = box();                  </span><br><span class="line">for (var i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">    alert(b[i]);                            //这里返回的是数组，直接打印即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改1中，我们<strong>让匿名函数进行自我执行</strong>，导致最终返回给a[i]的是数组而不是函数了。最终导致b[0]-b[4]中保留了0,1,2,3,4的值。</p>
<p>—循环里包含匿名函数-改2，匿名函数下再做个匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function box() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        arr[i] = (function (num) &#123;</span><br><span class="line">            return function () &#123;                //直接返回值，改2变成返回函数</span><br><span class="line">                return num;             //原理和改1一样</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = box();                  </span><br><span class="line">for (var i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">    alert(b[i]());                          //这里通过b[i]()函数调用即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改1和改2中，我们通过匿名函数自我执行，立即把结果赋值给a[i]。每一个i，是调用方通过按值传递的，所以最终返回的都是指定的递增的i。而不是box()函数里的i。</p>
<p>注意：es6的let也可以解决这个问题</p>
<h2 id="10-函数防抖-amp-函数节流"><a href="#10-函数防抖-amp-函数节流" class="headerlink" title="10.函数防抖&amp;函数节流"></a>10.函数防抖&amp;函数节流</h2><p>函数防抖（debounce）：<br>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间<br>函数节流（throttle）：<br>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期</p>
<p>函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</p>
<p>比如如下的情况：<br>window对象的resize、scroll事件<br>拖拽时的mousemove事件<br>文字输入、自动完成的keyup事件</p>
<p>区别：<br>可以拿我们平时坐电梯为例来形象地表述二者的区别<br>函数防抖：如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。<br>函数节流 ：保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行</p>
<h3 id="函数防抖："><a href="#函数防抖：" class="headerlink" title="函数防抖："></a>函数防抖：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123; </span><br><span class="line">  let timer = null;// 持久化一个定时器 timer</span><br><span class="line">  // 闭包函数可以访问 timer  </span><br><span class="line">  return function() &#123;</span><br><span class="line">    // 通过 &apos;this&apos; 和 &apos;arguments&apos;</span><br><span class="line">    // 获得函数的作用域和参数</span><br><span class="line">    let context = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    // 如果事件被触发，清除 timer 并重新开始计时</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(function() &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这个函数绑定在一个事件上，只有经过一段指定的时间后才会被调用。<br>你可以像这样去使用这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当用户滚动时函数会被调用</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&apos;You are scrolling!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 在事件触发的两秒后，我们包裹在debounce中的函数才会被触发</span><br><span class="line">let elem = document.getElementById(&apos;container&apos;);</span><br><span class="line">elem.addEventListener(&apos;scroll&apos;, debounce(foo, 2000));</span><br></pre></td></tr></table></figure>
<p>但是，仔细想想，上面的实现方式还是有一定的缺点。如果页面很长，我们一直在滚动页面，那_log方法就一直不会被执行。所以我们可以升级一下上述的防抖方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay,time)&#123;</span><br><span class="line">  </span><br><span class="line">  let timer = null;// 持久化一个定时器 timer</span><br><span class="line">  let previous = null; //记录上一次运行的时间</span><br><span class="line">  // 闭包函数可以访问 timer</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let now = +new Date();</span><br><span class="line">    if(!previous) previous = now;</span><br><span class="line">      //当上一次执行的时间与当前的时间差大于设置的执行间隔时长的话，就主动执行一次</span><br><span class="line">    let context = this;   // 通过 &apos;this&apos; 和 &apos;arguments&apos;</span><br><span class="line">    let args = arguments;    // 获得函数的作用域和参数</span><br><span class="line">   </span><br><span class="line">    if(now - previous &gt; time)&#123;</span><br><span class="line">      clearTimeout(timer); // 如果事件被触发，清除 timer 并重新开始计时</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      previous = now;// 执行函数后，马上记录当前时间</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      clearTimeout(timer); // 如果事件被触发，清除 timer 并重新开始计时</span><br><span class="line">      timer = setTimeout(function() &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数节流："><a href="#函数节流：" class="headerlink" title="函数节流："></a>函数节流：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, time) &#123; </span><br><span class="line"></span><br><span class="line">  let _self = fn, </span><br><span class="line">      timer,  </span><br><span class="line">      firstTime = true //记录是否是第一次执行的flag</span><br><span class="line"></span><br><span class="line">  return function() &#123; </span><br><span class="line">    let args = arguments, //解决闭包传参问题</span><br><span class="line">        _me = this //解决上下文丢失问题</span><br><span class="line"></span><br><span class="line">    if(firstTime) &#123; //若是第一次，则直接执行</span><br><span class="line">      _self.apply(_me, args)</span><br><span class="line">      return firstTime = false</span><br><span class="line">    &#125;</span><br><span class="line">    if(timer) &#123; //定时器存在，说明有事件监听器在执行，直接返回</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(function() &#123; </span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = null</span><br><span class="line">      _self.apply(_me, args)</span><br><span class="line">    &#125;, time || 500)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll = throttle(foo,500)</span><br></pre></td></tr></table></figure>
<h2 id="11-判断js类型"><a href="#11-判断js类型" class="headerlink" title="11.判断js类型"></a>11.判断js类型</h2><p>1.a instanceof Array</p>
<p>2.a.<strong>proto</strong>.constructor===Array</p>
<p>3.Object.prototype.toString.call(a)   //“[object Array]”（最好的方法）<br>-这个Object.prototype.toString.call()可以判断除了symbol以外的所有类型<br>对于Object.prototype.toString的返回格式通常是：<br>[object class] // class指的是对象类型<br>当调用a.toString()是，调用的是String.prototype.toString，返回的就是a的值</p>
<h2 id="12-javascript对象的8种创建方式"><a href="#12-javascript对象的8种创建方式" class="headerlink" title="12.javascript对象的8种创建方式"></a>12.javascript对象的8种创建方式</h2><blockquote>
<p><strong>1. 通过Object构造函数或对象字面量创建单个对象</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Person = new Object();</span><br><span class="line">Person.name = &apos;Nike&apos;;</span><br><span class="line">Person.age = 29;//Object构造函数创建</span><br><span class="line"></span><br><span class="line">var Person = &#123;&#125;;//使用对象字面量表示法;相当于var Person = new Object()</span><br><span class="line">var Person = &#123;</span><br><span class="line"> name:&apos;Nike&apos;;</span><br><span class="line"> age:29;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方式有明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个问题，出现了工厂模式。</p>
<blockquote>
<p><strong>2. 工厂模式</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line"> var o = new Object();</span><br><span class="line"> o.name = name;</span><br><span class="line"> o.age = age;</span><br><span class="line"> o.job = job;</span><br><span class="line"> o.sayName = function()&#123;</span><br><span class="line">  alert(this.name); </span><br><span class="line"> &#125;;</span><br><span class="line"> return o; </span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&apos;Nike&apos;,29,&apos;teacher&apos;);</span><br><span class="line">var person2 = createPerson(&apos;Arvin&apos;,20,&apos;student&apos;);</span><br></pre></td></tr></table></figure>
<p>在使用工厂模式创建对象的时候，我们都可以注意到，在createPerson函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式</p>
<blockquote>
<p><strong>3. 构造函数</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.job = job;</span><br><span class="line"> this.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;; </span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;Nike&apos;,29,&apos;teacher&apos;);</span><br><span class="line">var person2 = new Person(&apos;Arvin&apos;,20,&apos;student&apos;);</span><br></pre></td></tr></table></figure>
<p>对比工厂模式，我们可以发现以下区别：</p>
<ol>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
<li>要创建新实例，必须使用new操作符；（否则属性和方法将会被添加到window对象）</li>
<li>终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测</li>
</ol>
<blockquote>
<p><strong>4. 原型模式</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Nike&apos;;</span><br><span class="line">Person.prototype.age = 20;</span><br><span class="line">Person.prototype.jbo = &apos;teacher&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person1.name =&apos;Greg&apos;;</span><br><span class="line">alert(person1.name); //&apos;Greg&apos; --来自实例</span><br><span class="line">alert(person2.name); //&apos;Nike&apos; --来自原型</span><br></pre></td></tr></table></figure>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。<br>这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p>
<blockquote>
<p><strong>5. 组合使用构造函数模式和原型模式(完美)</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line"> this.name =name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> constructor:Person,</span><br><span class="line"> sayName: function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;Nike&apos;,20,&apos;teacher&apos;);</span><br></pre></td></tr></table></figure>
<p>创建自定义类型的最常用的方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性，这样每个实例都有自己的一份实例属性的副本，又同时共享着对方法的引用，最大限度的节省了内存。 </p>
<blockquote>
<p><strong>6. 动态原型模式</strong></p>
</blockquote>
<blockquote>
<p><strong>7. 寄生构造模式</strong></p>
</blockquote>
<blockquote>
<p><strong>8. 稳妥构造模式</strong></p>
</blockquote>
<h2 id="13-javascript继承6种方法"><a href="#13-javascript继承6种方法" class="headerlink" title="13.javascript继承6种方法"></a>13.javascript继承6种方法</h2><blockquote>
<p><strong>1.原型链继承</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//声明父类  </span><br><span class="line">function SuperClass() &#123;  </span><br><span class="line">  this.superValue = true;  </span><br><span class="line">&#125;  </span><br><span class="line">//为父类添加公有方法  </span><br><span class="line">SuperClass.prototype.getSuperValue = function () &#123;  </span><br><span class="line">  return this.superValue;  </span><br><span class="line">&#125;;  </span><br><span class="line">//声明子类  </span><br><span class="line">function SubClass() &#123;  </span><br><span class="line">  this.subValue = false;  </span><br><span class="line">&#125;  </span><br><span class="line">//继承父类  </span><br><span class="line">SubClass.prototype = new  SuperClass();//将父类对象赋值给子类原型，子类原型可访问父类原型上的属性和方法--类式继承原理  </span><br><span class="line">//子类添加公有方法  </span><br><span class="line">SubClass.prototype.getSubValue = function() &#123;  </span><br><span class="line">  return this.subValue;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">//测试  </span><br><span class="line">var instance = new SubClass();  </span><br><span class="line">console.log(instance.getSuperValue());//t  </span><br><span class="line">console.log(instance.getSubValue());//f  </span><br><span class="line">//  </span><br><span class="line">console.log(instance instanceof SuperClass);//t  </span><br><span class="line">console.log(instance instanceof SubClass);//t  </span><br><span class="line">console.log(SubClass instanceof SuperClass);//f  </span><br><span class="line">console.log(SubClass.prototype instanceof SuperClass);//t</span><br></pre></td></tr></table></figure>
<p>inatanceof是判断前面的对象是否是后面类（对象）的实例，并不表示两者的继承。所以console.log(SubCass instanceof SuperClass)会打印出false，而console.log(SubClass.prototype instanceof SuperClass)才会打印出true。</p>
<p>缺点：</p>
<ol>
<li>子类通过其原型prototype对父类实例化，继承了父类。但当父类中的共有属性是&lt;引用类型&gt;(基本类型不会共用)时，会在子类中被所有的实例共用，如此在一个子类实例中更改从父类中继承过来的公有属性时，会影响到其他子类。</li>
<li>由于子类是通过原型prototype实例化父类实现继承的，所以在创建父类的时候，无法向父类传递参数，因而在实例化父类的时候无法对父类构造函数内的属性初始化。</li>
</ol>
<blockquote>
<p><strong>2.构造函数式继承</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//声明父类  </span><br><span class="line">function SuperClass(id) &#123;  </span><br><span class="line">  this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];//引用类型共有属性  </span><br><span class="line">  this.id = id;//值类型公有属性  </span><br><span class="line">&#125;  </span><br><span class="line">//父类声明原型方法  </span><br><span class="line">SuperClass.prototype.showBooks = function() &#123;  </span><br><span class="line">  console.log(this.books);  </span><br><span class="line">&#125;  </span><br><span class="line">//声明子类  </span><br><span class="line">function SubClass(id) &#123;  </span><br><span class="line">  //继承父类  </span><br><span class="line">  SuperClass.call(this,id);  </span><br><span class="line">&#125;  </span><br><span class="line">//测试  </span><br><span class="line">var ins1 = new SubClass(1);  </span><br><span class="line">var ins2 = new SubClass(2);  </span><br><span class="line">ins1.book.push(&quot;Node&quot;);  </span><br><span class="line">console.log(ins1.id);//1  </span><br><span class="line">console.log(ins1.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos;]  </span><br><span class="line">console.log(ins2.id);//2  </span><br><span class="line">console.log(ins2.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]  </span><br><span class="line">  </span><br><span class="line">ins1.showBooks();//TypeError: ins1.showBooks is not a function</span><br></pre></td></tr></table></figure>
<p>SuperClass.call(this,id)是构造函数式继承的中心。call方法可以改变函数的作用环境，在子类中调用这个方法就是将子类中的变量在父类中执行，父类中给this绑定属性，因而子类继承了父类的共有属性。</p>
<p>缺点：<br>这种类型的继承没有涉及原型prototype，所以父类的原型方法不会被子类继承。如想被子类继承就必须放在构造函数中，这样创造的每个实例都会单独拥有一份而不能共用，违背了代码复用原则</p>
<blockquote>
<p><strong>3.组合继承(原型+构造)(良好)</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(name) &#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">  this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];  </span><br><span class="line">&#125;  </span><br><span class="line">SuperClass.prototype.getName = function () &#123;  </span><br><span class="line">  console.log(this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">function SubClass(name,time) &#123;  </span><br><span class="line">  //构造函数式继承，继承父类name属性  </span><br><span class="line">  SuperClass.call(this,name);  </span><br><span class="line">  this.time = time;  </span><br><span class="line">&#125;  </span><br><span class="line">//类式继承，子类原型继承  </span><br><span class="line">SubClass.prototype = new SuperClass();  </span><br><span class="line">//子类原型方法  </span><br><span class="line">SubClass.prototype.getTime = function () &#123;  </span><br><span class="line">  console.log(this.time);  </span><br><span class="line">&#125;;  </span><br><span class="line">//测试  </span><br><span class="line">var ins1 = new SubClass(&apos;Node&apos;,2016);  </span><br><span class="line">ins1.book.push(&quot;Node&quot;);  </span><br><span class="line">console.log(ins1.book);  //[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos;]  </span><br><span class="line">ins1.getName();  //Node</span><br><span class="line">ins1.getTime();  //2016</span><br><span class="line">  </span><br><span class="line">var ins2 = new SubClass(&apos;React&apos;,2015);  </span><br><span class="line">console.log(ins2.book);  //[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]  </span><br><span class="line">ins2.getName();  //React</span><br><span class="line">ins2.getTime();  //2015</span><br></pre></td></tr></table></figure>
<p>缺点：<br>父类的构造函数执行了两遍：一次在子类的构造函数中call方法执行一遍，一次在子类原型实例化父类的时候执行一遍。</p>
<blockquote>
<p><strong>4.原型式继承</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 生孩子函数inheritObject：龙inheritObject龙，凤inheritObject凤。</span><br><span class="line">function inheritObject(o) &#123;  </span><br><span class="line">  //声明过渡函数对象  </span><br><span class="line">  function F() &#123;&#125;  </span><br><span class="line">  //过渡对象的原型继承父类  </span><br><span class="line">  F.prototype = o;  </span><br><span class="line">  return new F();  </span><br><span class="line">&#125;  </span><br><span class="line">//测试  </span><br><span class="line">var book = &#123;  </span><br><span class="line">  name : &quot;javascript&quot;,  </span><br><span class="line">  book : [&apos;js&apos;,&apos;css&apos;]  </span><br><span class="line">&#125;;  </span><br><span class="line">var newbook = inheritObject(book);  </span><br><span class="line">newbook.name = &quot;ajax&quot;;  </span><br><span class="line">newbook.book.push(&quot;Node&quot;);  </span><br><span class="line">var otherbook = inheritObject(book);  </span><br><span class="line">otherbook.name = &quot;xml&quot;;  </span><br><span class="line">otherbook.book.push(&quot;React&quot;);  </span><br><span class="line">console.log(newbook.name);//ajax  </span><br><span class="line">console.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]  </span><br><span class="line">console.log(otherbook.name);//xml  </span><br><span class="line">console.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]  </span><br><span class="line">console.log(book.name);//javascript  </span><br><span class="line">console.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</span><br></pre></td></tr></table></figure>
<p>简介：对类式继承的封装，过渡对象相当于子类<br>缺点：和原型链继承一样，父类对象的引用类型值被共用。</p>
<blockquote>
<p><strong>5.寄生式继承</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function inheritObject(o) &#123;  </span><br><span class="line">  //声明过渡函数对象  </span><br><span class="line">  function F() &#123;&#125;  </span><br><span class="line">  //过渡对象的原型继承父类  </span><br><span class="line">  F.prototype = o;  </span><br><span class="line">  return new F();  </span><br><span class="line">&#125;  </span><br><span class="line">//声明基对象  </span><br><span class="line">var book = &#123;  </span><br><span class="line">  name : &quot;javascript&quot;,  </span><br><span class="line">  book : [&apos;js&apos;,&apos;css&apos;]  </span><br><span class="line">&#125;;  </span><br><span class="line">function createBook(obj) &#123;  </span><br><span class="line">  //通过原型继承方式创建新对象  </span><br><span class="line">  var o = new inheritObject(obj);  </span><br><span class="line">  //拓展新对象  </span><br><span class="line">  o.getName = function() &#123;  </span><br><span class="line">    console.log(name);  </span><br><span class="line">  &#125;  </span><br><span class="line">  //返回拓展后的新对象  </span><br><span class="line">  return o;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">var newbook = createBook(book);  </span><br><span class="line">newbook.name = &quot;ajax&quot;;  </span><br><span class="line">newbook.book.push(&quot;Node&quot;);  </span><br><span class="line">var otherbook = createBook(book);  </span><br><span class="line">otherbook.name = &quot;xml&quot;;  </span><br><span class="line">otherbook.book.push(&quot;React&quot;);  </span><br><span class="line">console.log(newbook.name);//ajax  </span><br><span class="line">console.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]  </span><br><span class="line">console.log(otherbook.name);//xml  </span><br><span class="line">console.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]  </span><br><span class="line">console.log(book.name);//javascript  </span><br><span class="line">console.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</span><br></pre></td></tr></table></figure>
<p>简介：给原型式继承穿了个马甲而已，看起来更像继承了（上面介绍的原型式继承更像是对象复制）<br>注意：inheritObject函数并不是必须的，换言之，创建新对象 -&gt; 增强 -&gt; 返回该对象，这样的过程叫寄生式继承，新对象是如何创建的并不重要（用inheritObject生的，new出来的，字面量现做的。。都可以）,无法实现函数复用（没用到原型，当然不行）</p>
<blockquote>
<p><strong>6.寄生组合式继承(完美)</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 生孩子函数inheritObject：龙inheritObject龙，凤inheritObject凤。</span><br><span class="line">function inheritObject(o) &#123;  </span><br><span class="line">  //声明过渡函数对象  </span><br><span class="line">  function F() &#123;&#125;  </span><br><span class="line">  //过渡对象的原型继承父类  </span><br><span class="line">  F.prototype = o;  </span><br><span class="line">  return new F();  </span><br><span class="line">&#125;  </span><br><span class="line">//寄生式继承 继承原型  </span><br><span class="line">function inheritPrototype(subClass,superClass) &#123;  </span><br><span class="line">  //复制一份父类的原型副本保存在变量中  </span><br><span class="line">  var p = inheritObject(superClass.prototype);  </span><br><span class="line">  //修正因为重写子类原型导致子类的constructor属性被修改  </span><br><span class="line">  p.constructor = subClass;  </span><br><span class="line">  //设置子类的原型  </span><br><span class="line">  subClass.prototype = p;  </span><br><span class="line">&#125;  </span><br><span class="line">function SuperClass(name) &#123;  </span><br><span class="line">  this.name = name;  </span><br><span class="line">  this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];  </span><br><span class="line">&#125;  </span><br><span class="line">//定义父类原型方法  </span><br><span class="line">SuperClass.prototype.getName = function() &#123;  </span><br><span class="line">  console.log(this.name);  </span><br><span class="line">&#125;  </span><br><span class="line">function SubClass(name,time) &#123;  </span><br><span class="line">  SuperClass.call(this,name);  </span><br><span class="line">  this.time = time;  </span><br><span class="line">&#125;  </span><br><span class="line">//寄生式继承父类原型  </span><br><span class="line">inheritPrototype(SubClass,SuperClass);  </span><br><span class="line">//子类新增原型方法  </span><br><span class="line">SubClass.prototype.getTime = function() &#123;  </span><br><span class="line">  console.log(this.time);  </span><br><span class="line">&#125;  </span><br><span class="line">//测试  </span><br><span class="line">var ins1 = new SubClass(&quot;js&quot;,2014);  </span><br><span class="line">var ins2 = new SubClass(&quot;css&quot;,2015);  </span><br><span class="line">ins1.colors.push(&quot;black&quot;);  </span><br><span class="line">console.log(ins1.colors);  // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line">console.log(ins2.colors);  //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">ins2.getName();  //css</span><br><span class="line">ins2.getTime();  //2015</span><br></pre></td></tr></table></figure>
<p>用inheritObject(Super.prototype);切掉了原型对象上多余的那份父类实例属性;完美！</p>
<h2 id="14-js实现懒加载"><a href="#14-js实现懒加载" class="headerlink" title="14.js实现懒加载"></a>14.js实现懒加载</h2><blockquote>
<p><strong>为什么要懒加载</strong></p>
</blockquote>
<p>懒加载（LazyLoad）是前端优化的一种有效方式，极大的提升用户体验，图片一直是页面加载的流浪大户，现在一张图片几兆已经是很正常的事，远远大于代码的大小。倘若一次ajax请求过来10张图片的地址，我想如果你一次性把10张图片都加载出来，肯定是不合理的。</p>
<blockquote>
<p><strong>懒加载的实现原理</strong></p>
</blockquote>
<p>原理很简单，先把img的src指向空或者一个小图片，图片真实的地址存储在img一个自定义的属性里,&lt; img src=” data-src=”<a href="http://real.com/real.jpg" target="_blank" rel="noopener">http://real.com/real.jpg</a>“ /&gt;,等到此图片出现在视野范围内了，获取img元素，把data-src里的值赋给src。<br>一般也会配合函数防抖和节流用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var aImg = document.querySelectorAll(&apos;img&apos;);</span><br><span class="line">        var len = aImg.length;</span><br><span class="line">        var n = 0;//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span><br><span class="line">        window.onscroll = function() &#123;</span><br><span class="line">            var seeHeight = document.documentElement.clientHeight;//窗口可视高度</span><br><span class="line">            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;//滚动条隐藏高度</span><br><span class="line">            for (var i = n; i &lt; len; i++) &#123;</span><br><span class="line">                if (aImg[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">                    if (aImg[i].getAttribute(&apos;src&apos;) == &apos;&apos;) &#123;</span><br><span class="line">                        aImg[i].src = aImg[i].getAttribute(&apos;data-src&apos;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    n = i + 1;</span><br><span class="line">                    console.log(&apos;n = &apos; + n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">//具体实现时还需要实现页面一进来的时候就判断加载图片以及函数节流</span><br></pre></td></tr></table></figure>
<h2 id="15-分时函数？"><a href="#15-分时函数？" class="headerlink" title="15.分时函数？"></a>15.分时函数？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function repeat(func, times, wait) &#123;</span><br><span class="line">            return function () &#123;</span><br><span class="line">                var handle, i = 0,arg = arguments</span><br><span class="line">                handle = setInterval(function () &#123;</span><br><span class="line">                    if (i++ === times) &#123;</span><br><span class="line">                        clearInterval(handle);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    func.apply(null, arg);</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var repeatFun = repeat(console.log, 4, 1000);</span><br><span class="line">        repeatFun(&quot;hellworld&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="16-兼容ie和chrome的检测滚动条是否已经在底部"><a href="#16-兼容ie和chrome的检测滚动条是否已经在底部" class="headerlink" title="16.兼容ie和chrome的检测滚动条是否已经在底部"></a>16.兼容ie和chrome的检测滚动条是否已经在底部</h2><p>总体来说就是：窗口高度+滚动条高度 = 文档高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onscroll=function()&#123;</span><br><span class="line">  var a = document.documentElement.scrollTop==0? document.body.clientHeight : document.documentElement.clientHeight;</span><br><span class="line">  var b = document.documentElement.scrollTop==0? document.body.scrollTop : document.documentElement.scrollTop;</span><br><span class="line">  var c = document.documentElement.scrollTop==0? document.body.scrollHeight : document.documentElement.scrollHeight;</span><br><span class="line">  if(a+b==c)&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或用jq</span><br><span class="line"> $(window).height() + $(document).scrollTop()  == $(document).height()</span><br></pre></td></tr></table></figure>
<h2 id="17-常见的兼容的问题总结"><a href="#17-常见的兼容的问题总结" class="headerlink" title="17.常见的兼容的问题总结"></a>17.常见的兼容的问题总结</h2><blockquote>
<p><strong>= =js直接看源链接吧</strong></p>
</blockquote>
<p><a href="http://www.jb51.net/article/100373.htm" target="_blank" rel="noopener">http://www.jb51.net/article/100373.htm</a></p>
<blockquote>
<p><strong>css</strong></p>
</blockquote>
<blockquote>
<blockquote>
<p>块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大（即双倍边距bug）</p>
</blockquote>
</blockquote>
<ul>
<li>问题症状：常见症状是IE6中后面的一块被顶到下一行</li>
<li>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</li>
</ul>
<blockquote>
<blockquote>
<p>设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</p>
</blockquote>
</blockquote>
<ul>
<li>问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</li>
<li>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</li>
<li>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高</li>
</ul>
<blockquote>
<blockquote>
<p>图片默认有间距</p>
</blockquote>
</blockquote>
<ul>
<li>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</li>
<li>解决方案：使用float属性为img布局备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。使用float是正道。</li>
</ul>
<blockquote>
<blockquote>
<p>标签最低高度设置min-height不兼容</p>
</blockquote>
</blockquote>
<ul>
<li>问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</li>
<li>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</li>
<li>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</li>
</ul>
<h1 id="四-往数据库一个字段存对象问题："><a href="#四-往数据库一个字段存对象问题：" class="headerlink" title="四.往数据库一个字段存对象问题："></a>四.往数据库一个字段存对象问题：</h1><p> <img src="/images/csj.jpg" alt=""><br> 这是最近用vue做一个小东西时遇到了一点问题，稍微整理了一下，以免以后看不懂~</p>
<h1 id="五-原型链与闭包"><a href="#五-原型链与闭包" class="headerlink" title="五.原型链与闭包"></a>五.原型链与闭包</h1><p> <img src="/images/yxl.png" alt=""></p>
<p>1-Instanceof的判断队则是：沿着A的——proto——这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。instanceof表示的就是一种继承关系，或者原型链的结构</p>
<p>2-（undefined, number, string,boolean）属于简单的值类型，不是对象。<br>（函数、数组、对象、null、new Number(10)）都是对象。他们都是引用类型<br>-值类型的类型判断用typeof，引用类型的类型判断用instanceof。</p>
<p>3-对象都是通过函数创建的= =<br>console.log(typeof (Object));  // function<br>console.log(typeof (Array));  // function</p>
<p>4-每个对象都有一个——proto——属性，指向创建该对象的函数的prototype。<br>但是Object.prototype确实一个特例——它的——proto——指向的是null，切记切记！</p>
<p>5-传值传参的时候，我们在函数中改变了参数的值，其对应的变量的值并不改变，值类型传参就是将变量保存的内容复制到函数的形参中，他们是两个不同的变量，值不过保存的内容相同不了.<br>引用传参保存的是一个地址，这个地址里保存的是变量的具体值，而引用类型作为参数的时候，是将变量保存的地址值赋值到参数变量里，这样他们都指向了同一个内容，这样我们改变参数的成员的话，那么相应的变量的成员也会改变。<br>(JS没有按引用传参的功能，不能把传递引用类型的参数当做按引用传参)</p>
<p>6-访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着——proto——这条链向上找（即它的构造函数的prototype），这就是原型链</p>
<p>7-hasOwnProperty：区分一个属性到底是基本的还是从原型中找到的,是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。<br>isPrototypeOf:是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false</p>
<p>8-由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的”继承”。</p>
<p>9-总图中：<br>对象的——proto——最终都是指向Object.prototype;<br>函数的——proto——都是指向Function.prototype;<br>而Function.prototype的——proto——就是Object.prototype</p>
<p>10-<br>变量、函数表达式——变量声明，默认赋值为undefined；<br>this——赋值；<br>函数声明——赋值；<br>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</p>
<p>11-<br>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p>
<p>12-如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</p>
<p>13-es5中：我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</p>
<p>14-jQuery源码的最外层是一个自动执行的匿名函数：</p>
<p>15-在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量，自由变量要到创建这个函数的那个作用域中取值——是”创建”，而不是”调用”，切记切记——其实这就是所谓的”<strong>静态作用域</strong>“！！！<br>js没有块级作用域，只有函数和全局作用域</p>
<p>16-使用闭包会增加内容开销=&gt;(有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了)作用域链的机制导致一个问题，在循环中里的匿名函数取得的任何变量都是最后一个值。</p>
<p>17-闭包的使用场景(1.函数作为返回值/2.函数作为参数传递)</p>
<p>18-原型链例子的链式操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Elem(id)&#123;</span><br><span class="line">  this.elem = document.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.prototype.html = function(val)&#123;</span><br><span class="line">  var elem = this.elem;</span><br><span class="line">  if(val)&#123;</span><br><span class="line">    elem.innerHTML = val</span><br><span class="line">    return this // 使其可以链式操作</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return elem.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.prototype.on = function(type, fn)&#123;</span><br><span class="line">  var elem = this.elem;</span><br><span class="line">  elem.addEventListener(type, fn)</span><br><span class="line">  return this; //使其可以链式操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var som = new Elem(&apos;xxx&apos;)</span><br><span class="line">// console.log(som.html())</span><br><span class="line">som.html(&apos;&lt;p&gt;hello world&lt;/p&gt;&apos;).on(&apos;click&apos;,function () &#123;</span><br><span class="line">  alert(&apos;click som&apos;);</span><br><span class="line">  &#125;).html(&apos;&lt;p&gt; 链式操作 &lt;/p&gt;&apos;);</span><br></pre></td></tr></table></figure>
<p>19-闭包例子(描述了闭包的使用场景)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function F1()&#123;</span><br><span class="line">  var a = 100 //注意假如这里没有定义a的话就会直接报错了</span><br><span class="line">  return function()&#123;</span><br><span class="line">    console.log(a)//自由变量</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = F1()</span><br><span class="line"></span><br><span class="line">function F2(fn)&#123;</span><br><span class="line">  var a =200</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">F2(f1)</span><br></pre></td></tr></table></figure>
<p>20-this和没有this/声明和没有声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var x = 3;</span><br><span class="line">function func(randomize) &#123;</span><br><span class="line">    var x;</span><br><span class="line">    if (randomize) &#123;</span><br><span class="line">        x = Math.random();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">func(false);// undefined</span><br><span class="line"></span><br><span class="line">var x = 3;</span><br><span class="line">function func(randomize) &#123;</span><br><span class="line">    var x;</span><br><span class="line">    if (randomize) &#123;</span><br><span class="line">        x = Math.random();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.x;</span><br><span class="line">&#125;</span><br><span class="line">func(false); //3</span><br><span class="line"></span><br><span class="line">var x = 3;</span><br><span class="line">function func(randomize) &#123;</span><br><span class="line">    if (randomize) &#123;</span><br><span class="line">        x = Math.random();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">func(false); //3</span><br><span class="line"></span><br><span class="line">var x = 3;</span><br><span class="line">function func(randomize) &#123;</span><br><span class="line">    if (randomize) &#123;</span><br><span class="line">        var x = Math.random(); // </span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x; </span><br><span class="line">&#125;</span><br><span class="line">func(false); // undefined</span><br></pre></td></tr></table></figure>
<p>21- JavaScript原型继承中constructor的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function A()</span><br><span class="line">&#123;</span><br><span class="line">    this.name = &quot;A&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function B()</span><br><span class="line">&#123;</span><br><span class="line">    this.name = &quot;B&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">B.prototype = new A();</span><br><span class="line"> </span><br><span class="line">var b = new B();</span><br><span class="line">alert(b.constructor); // 显示function A()</span><br><span class="line">alert(b.name); // B;</span><br><span class="line"></span><br><span class="line">//若加上B.prototype.constructor = B;</span><br><span class="line">alert(b.constructor); //显示function B()</span><br></pre></td></tr></table></figure>
<p>这句话改变了函数B的默认原型对象，本来B的新原型对象是构造函数A的一个实例，所以，b.constructor其实是A的实例的constructor属性，而A的实例的constructor属性，就是A的原型的constructor属性，即A这个函数对象</p>
<p>总结：在不改变构造函数原型的情况下，构造函数的实例的constructor属性指向构造函数对象</p>
<p>21-函数提升在变量提升上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo);</span><br><span class="line">    var foo=10;</span><br><span class="line">    console.log(foo); //f</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        console.log(10); //10</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo); //10</span><br><span class="line">//相当于</span><br><span class="line">function foo()&#123;</span><br><span class="line">        console.log(10);</span><br><span class="line">    &#125;</span><br><span class="line">var foo;</span><br><span class="line">console.log(foo); </span><br><span class="line">foo=10;</span><br><span class="line">console.log(foo); </span><br><span class="line">console.log(foo);</span><br></pre></td></tr></table></figure>
<h1 id="六-Promise"><a href="#六-Promise" class="headerlink" title="六.Promise"></a>六.Promise</h1><blockquote>
<p><strong>es5的“回调地狱”背景</strong>：</p>
</blockquote>
<p>回调遭受着<strong>控制反转</strong>的蹂躏，它们隐含地将控制权交给第三方（通常第三方工具不受你控制！）来调用你程序的 延续。这种控制权的转移使我们得到一张信任问题的令人不安的列表，比如回调是否会比我们期望的被调用更多次。<br>制造特殊的逻辑来解决这些信任问题是可能的，但是它比它应有的难度高多了，还会产生更笨重和更难维护的代码，而且在bug实际咬到你的时候代码会显得在这些危险上被保护的不够。</p>
<blockquote>
<p><strong>特点</strong>：</p>
</blockquote>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending(进行中)、fulfilled(已成功)和rejected(已失败)。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。</li>
<li>它的精髓是通过维护状态、传递状态的方式来使回调方式能够及时的调用</li>
<li>reject(..)简单地拒绝promise，但是resolve(..)既可以完成promise，也可以拒绝promise，这要看它被传入什么值。如果resolve(..)被传入一个立即的，非Promise，非thenable的值，那么这个promise将用这个值完成。</li>
<li>它们没有摆脱回调，而是重新定向了这些回调的组织安排方式，是它成为一种坐落于我们和其他工具之间的可靠的中间机制</li>
<li>如果resolve(..)被传入一个Promise或者thenable的值，那么这个值将被递归地展开，而且无论它最终解析结果/状态是什么，都将被promise采用，而且将它展开直至非thenable值。但你会从Promise.resolve(..)那里得到一个真正的，纯粹的Promise，一个你可以信任的东西</li>
<li>将任意函数的返回值（thenable或不是thenable）包装在Promise.resolve(..)中的另一个好的副作用是，它可以很容易地将函数调用泛化为一个行为规范的异步任务。如果foo(42)有时返回一个立即值，而其他时候返回一个Promise，Promise.resolve(foo(42))，将确保它总是返回Promise。并且使代码成为回避Zalgo效应的更好的代码。</li>
<li>如果你试着用一个偶然拥有then(..)函数的任意对象/函数来完成一个Promise，但你又没想把它当做一个Promise/thenable来对待，你的运气就用光了，因为它会被自动地识别为一个thenable并以特殊的规则来对待，要小心，如果thenable鸭子类型将不是Promise的东西误认为是Promise，它就可能成为灾难</li>
</ol>
<blockquote>
<p><strong>使链式流程控制成为可能的Promise固有行为</strong>：</p>
</blockquote>
<ol>
<li>在一个Promise上的then(..)调用会自动生成一个新的Promise并返回。</li>
<li>在完成/拒绝处理器内部，如果你返回一个值或抛出一个异常，新返回的Promise（可以被链接的）将会相应地被解析。</li>
<li>如果完成或拒绝处理器返回一个Promise，它会被展开，所以无论它被解析为什么值，这个值都将变成从当前的then(..)返回的被链接的Promise的解析</li>
</ol>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ol>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>（<br>解决：<br>(1)设置setTimeout,从拒绝的那一刻开始计时。如果一个Promise被拒绝但没有错误处理在计时器被触发前注册，那么它就假定你不会注册监听器了，所以它是“未被捕获的”。<br>(2).done( null, handleErrors );<br>）</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
<li>Promise只能有一个单独的完成值或一个单独的拒绝理由。</li>
</ol>
<blockquote>
<p><strong>使用promise的步骤如下：</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunc() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        // some async task</span><br><span class="line">        if (/*异步操作成功*/) &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc().then(function(value) &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用catch来区分成功失败会更好:</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    log(&apos;start new Promise...&apos;);</span><br><span class="line">    var timeOut = Math.random() * 2;</span><br><span class="line">    log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        if (timeOut &lt; 1) &#123;</span><br><span class="line">            log(&apos;call resolve()...&apos;);</span><br><span class="line">            resolve(&apos;200 OK&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            log(&apos;call reject()...&apos;);</span><br><span class="line">            reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * 1000);</span><br><span class="line">&#125;).then(function (r) &#123;</span><br><span class="line">    log(&apos;Done: &apos; + r);</span><br><span class="line">&#125;).catch(function (reason) &#123;</span><br><span class="line">    log(&apos;Failed: &apos; + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考链接：<br><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000</a></p>
<blockquote>
<p><strong>重写setTimeout</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var wait1000 =  new Promise(function(resolve, reject) &#123;</span><br><span class="line">  setTimeout(resolve, 1000)</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;Yay!&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//或者用ES6的箭头函数：</span><br><span class="line"></span><br><span class="line">var wait1000 =  new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 1000)</span><br><span class="line">&#125;).then(()=&gt; &#123;</span><br><span class="line">  console.log(&apos;Yay!&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//逻辑内嵌在setTimeout()中的回调时:</span><br><span class="line"></span><br><span class="line">var wait1000 = ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;)</span><br><span class="line"> </span><br><span class="line">wait1000()</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">        console.log(&apos;Yay!&apos;)</span><br><span class="line">        return wait1000() //使其可以一直then</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">        console.log(&apos;Wheeyee!&apos;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>promise.all方法：</strong></p>
</blockquote>
<p>Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。如果其中任意一个promise被拒绝，Promise.all([ .. ]的主Promise将立即被拒绝，并放弃所有其他promise的结果。要记得总是给每个promise添加拒绝/错误处理器，即使和特别是那个从Promise.all([ .. ])返回的promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(&quot;第一个promise&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 = new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(&quot;第二个promise&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then(function (result) &#123;</span><br><span class="line">    console.log(result); // [&quot;第一个promise&quot;, &quot;第二个promise&quot;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//上面的代码中，all接收一个数组作为参数，p1,p2是并行执行的，等两个都执行完了，才会进入到then，all会把所有的结果放到一个数组中返回，所以我们打印出我们的结果为一个数组。</span><br><span class="line"></span><br><span class="line">//值得注意的是，虽然p2的执行顺序比p1快，但是all会按照参数里面的数组顺序来返回结果。all的使用场景类似于，玩游戏的时候，需要提前将游戏需要的资源提前准备好，才进行页面的初始化</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>promise.race方法：</strong></p>
</blockquote>
<p>race的中文意思为赛跑，也就是说，看谁跑的快，跑的快的就赢了。因此，promise.race也是传入一个数组，但是与promise.all不同的是，race只返回跑的快的值，也就是说result返回比较快执行的那个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">        resolve(&quot;第一个promise&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 = new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        resolve(&quot;第二个promise&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then(function (result) &#123;</span><br><span class="line">    console.log(result); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 结果：</span><br><span class="line">// 2</span><br><span class="line">// 第二个promise</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>警告： 要小心！如果一个空的array被传入Promise.all([ .. ])，它会立即完成，但Promise.race([ .. ])却会永远挂起，永远不会解析。</p>
<blockquote>
<p><strong>实现一个promise</strong></p>
</blockquote>
<p>思路：<img src="/images/promise1.jpg" alt=""><br>实现：<a href="https://segmentfault.com/a/1190000009792439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009792439</a></p>
<h1 id="七-跨域了解一下"><a href="#七-跨域了解一下" class="headerlink" title="七.跨域了解一下~"></a>七.跨域了解一下~</h1><blockquote>
<p><strong>什么是跨域：</strong></p>
</blockquote>
<ul>
<li>浏览器有同源策略，不允许ajax访问其他域接口，所有跨域请求都必须经过信息提供方的同意</li>
<li>img用于打点统计，统计网站可能是其他域</li>
<li>link、script可以使用CDN,CDN的也是其他域</li>
<li>script用于JSONP</li>
</ul>
<blockquote>
<p><strong>跨域条件：</strong></p>
</blockquote>
<p>协议，域名，端口（有一个不同就算跨域）</p>
<blockquote>
<p><strong>用到的一些api：</strong></p>
</blockquote>
<p>onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发。<br>锚部分的实例：指定当前 URL 为<a href="http://www.example.com/test.htm#part2" target="_blank" rel="noopener">http://www.example.com/test.htm#part2</a>这个 URL 中的锚部分为 #part2。<br>你可以使用以下方式调用事件:<br>1.通过设置Location 对象 的 location.hash 或 location.href 属性修改锚部分。<br>2.使用不同书签导航到当前页面（使用”后退” 或”前进”按钮）<br>3.点击链接跳转到书签锚</p>
<p>contentDocument 属性能够以 HTML 对象来返回 iframe 中的文档。<br>可以通过所有标准的 DOM 方法来处理被返回的对象。</p>
<p>Window open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。<br>window.parent中parent表示父窗口，比如一个A页面利用iframe或frame调用B页面，那么A页面就是B页面的parent。B页面可以通过parent访问A页面。<br>window.opener中的opener表示谁打开我的，比如一个A页面利用window.open弹出了B页面，那么A页面就是B页面的opener。B页面可以通过opener访问A页面。<br>Document 对象open() 方法可打开一个新文档，并擦除当前文档的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createNewDoc()</span><br><span class="line">  &#123;</span><br><span class="line">  var newDoc=document.open(&quot;text/html&quot;,&quot;replace&quot;);</span><br><span class="line">  var txt=&quot;&lt;html&gt;&lt;body&gt;学习 DOM 非常有趣！&lt;/body&gt;&lt;/html&gt;&quot;;</span><br><span class="line">  newDoc.write(txt);</span><br><span class="line">  newDoc.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源</p>
<h2 id="1-Cookie-document-domain"><a href="#1-Cookie-document-domain" class="headerlink" title="1/Cookie(document.domain)"></a>1/Cookie(document.domain)</h2><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。<br>举例来说，A网页是<a href="http://w1.example.com/a.html" target="_blank" rel="noopener">http://w1.example.com/a.html</a>，B网页是<a href="http://w2.example.com/b.html" target="_blank" rel="noopener">http://w2.example.com/b.html</a>，那么只要设置相同的document.domain，两个网页就可以共享Cookie。<br>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。<br>document.domain 默认的值是整个域名，所以即使两个域名的二级域名一样，那么他们的 document.domain 也不一样。</p>
<h2 id="2-iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。"><a href="#2-iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。" class="headerlink" title="2/iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。"></a>2/iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</h2><blockquote>
<p>/片段识别符（fragment identifier）</p>
</blockquote>
<blockquote>
<p>/window.name</p>
</blockquote>
<blockquote>
<p>/跨文档通信API（Cross-document messaging）</p>
</blockquote>
<h3 id="片段标识符（fragment-identifier）指的是，URL的-号后面的部分，"><a href="#片段标识符（fragment-identifier）指的是，URL的-号后面的部分，" class="headerlink" title="片段标识符（fragment identifier）指的是，URL的#号后面的部分，"></a>片段标识符（fragment identifier）指的是，URL的#号后面的部分，</h3><p>比如<a href="http://example.com/x.html#fragment" target="_blank" rel="noopener">http://example.com/x.html#fragment</a>的#fragment。如果只是改变片段标识符，页面不会重新刷新。<br>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var src = originURL + &apos;#&apos; + data;</span><br><span class="line">document.getElementById(&apos;myIFrame&apos;).src = src;</span><br><span class="line">子窗口通过监听hashchange事件得到通知。</span><br><span class="line">window.onhashchange = checkMessage;</span><br><span class="line">function checkMessage() &#123;</span><br><span class="line">  var message = window.location.hash;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">同样的，子窗口也可以改变父窗口的片段标识符。</span><br><span class="line">parent.location.href= target + &quot;#&quot; + hash;</span><br></pre></td></tr></table></figure>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。<br>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。<br>window.name = data;<br>接着，子窗口跳回一个与主窗口同域的网址。location = <a href="http://parent.url.com/xxx.html" target="_blank" rel="noopener">http://parent.url.com/xxx.html</a>;然后，主窗口就可以读取子窗口的window.name了。<br>var data = document.getElementById(‘myFrame’).contentWindow.name;<br>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。<br>举例来说，父窗口<a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a>向子窗口<a href="http://bbb.com" target="_blank" rel="noopener">http://bbb.com</a>发消息，调用postMessage方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure>
<p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为（all的符号），表示不限制域名，向所有窗口发送。<br>子窗口向父窗口发送消息的写法类似。<br>window.opener.postMessage(‘Nice to see you’, ‘<a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a>‘);<br>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>
<p>message事件的事件对象event，提供以下三个属性。<br>event.source：发送消息的窗口<br>event.origin: 消息发向的网址<br>event.data: 消息内容<br>下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>event.origin属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  if (event.origin !== &apos;http://aaa.com&apos;) return;</span><br><span class="line">  if (event.data === &apos;Hello World&apos;) &#123;</span><br><span class="line">      event.source.postMessage(&apos;Hello&apos;, event.origin);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-AJAX：（JSONP-WebSocket-CORS）"><a href="#3-AJAX：（JSONP-WebSocket-CORS）" class="headerlink" title="3/AJAX：（JSONP/WebSocket/CORS）"></a>3/AJAX：（JSONP/WebSocket/CORS）</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。首先，网页动态插入script元素，由它向跨源网址发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">  //document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码通过动态添加script元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
<h3 id="WebSocket是一种通信协议，使用ws-（非加密）和wss-（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。"><a href="#WebSocket是一种通信协议，使用ws-（非加密）和wss-（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。" class="headerlink" title="WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。"></a>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</h3><h3 id="CORS是跨源资源分享（Cross-Origin-Resource-Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。"><a href="#CORS是跨源资源分享（Cross-Origin-Resource-Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。" class="headerlink" title="CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。"></a>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</h3><p>源链接：<br><a href="http://blog.csdn.net/dreamcatcher1314/article/details/78652884（了解跨域）-" target="_blank" rel="noopener">http://blog.csdn.net/dreamcatcher1314/article/details/78652884（了解跨域）-</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html（跨域资源共享CORS服务器端）-" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html（跨域资源共享CORS服务器端）-</a><br><a href="https://segmentfault.com/a/1190000003642057（跨域解决详解）：" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003642057（跨域解决详解）：</a></p>
<h1 id="八-笔记算法"><a href="#八-笔记算法" class="headerlink" title="八.笔记算法= ="></a>八.笔记算法= =</h1><h2 id="1-最大公约数-amp-最小公倍数"><a href="#1-最大公约数-amp-最小公倍数" class="headerlink" title="1.最大公约数&amp;最小公倍数"></a>1.最大公约数&amp;最小公倍数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while( max % min )&#123;  </span><br><span class="line">temp = max % min;  </span><br><span class="line">max = min;  </span><br><span class="line">min = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">return min;  //最大公约数（辗转相除法）</span><br><span class="line"></span><br><span class="line">而最小公倍数=a*b/最大公约数(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="2-回文"><a href="#2-回文" class="headerlink" title="2.回文"></a>2.回文</h2><h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h2><blockquote>
<p>1-<br>冒泡排序,循环一次,就确定了最后一位最大值(针对升序),从全部遍历到单个单个<br>插入排序 循环一次 则将有序区间增加一位,单个单个遍历到全部</p>
</blockquote>
<h1 id="九-Ajax-Asynchronous-JavaScript-and-XML"><a href="#九-Ajax-Asynchronous-JavaScript-and-XML" class="headerlink" title="九.Ajax(Asynchronous JavaScript and XML)"></a>九.Ajax(Asynchronous JavaScript and XML)</h1><h2 id="ajax的原理"><a href="#ajax的原理" class="headerlink" title="ajax的原理"></a>ajax的原理</h2><ul>
<li>相当于在客户端与服务端之间加了一个抽象层(Ajax引擎)，使用户请求和服务器响应异步化，并不是所有的请求都提交给服务器，像一些数据验证和数据处理都交给Ajax引擎来完成，只有确认需要向服务器读取新数据时才右Ajax引擎向服务器提交请求。</li>
</ul>
<p>使用XHTML+CSS来标准化呈现；<br>使用XML和XSLT进行数据交换及相关操作；<br>使用XMLHttpRequest对象与Web服务器进行异步数据通信；<br>使用Javascript操作Document Object Model进行动态显示及交互；<br>使用JavaScript绑定和处理所有数据。</p>
<h2 id="ajax的过程-问答题"><a href="#ajax的过程-问答题" class="headerlink" title="ajax的过程(问答题)"></a>ajax的过程(问答题)</h2><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    var xmlHttp = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xmlHttp.open(&apos;GET&apos;,&apos;demo.php&apos;,&apos;true&apos;);</span><br><span class="line"></span><br><span class="line">    xmlHttp.send()</span><br><span class="line"></span><br><span class="line">    xmlHttp.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">        if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">readyState ： 0 = 未初始化，1 = 启动， 2 = 发送，3 = 接收，4 = 完成</span><br></pre></td></tr></table></figure>
<p>参考链接(一定要看！)：<br><a href="https://blog.csdn.net/shuidinaozhongyan/article/details/71480872?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/shuidinaozhongyan/article/details/71480872?locationNum=7&amp;fps=1</a></p>
<h2 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h2><ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li>无刷新更新数据:<br>Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信</li>
<li>异步与服务器通信:<br>使用异步的方式与服务器通信，不打断用户的操作</li>
<li>前端与后端负载均衡:<br>将一些后端的工作移到前端，减少服务器与带宽的负担</li>
<li>基于规范被广泛支持:<br>不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li>Ajax干掉了Back与History功能，即对浏览器机制的破坏</li>
<li>安全问题：<br>AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。</li>
<li>对搜索引擎支持较弱</li>
<li>破坏程序的异常处理机制</li>
<li>违背URL与资源定位的初衷(例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。)</li>
<li>不能很好地支持移动设备</li>
</ol>
<h2 id="ajax与jsonp-例子在跨域那个点有"><a href="#ajax与jsonp-例子在跨域那个点有" class="headerlink" title="ajax与jsonp(例子在跨域那个点有)"></a>ajax与jsonp(例子在跨域那个点有)</h2><blockquote>
<p><strong>jsonp的产生原因</strong></p>
</blockquote>
<ol>
<li>Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准）</li>
<li>web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe）</li>
<li>可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理；</li>
<li>json的纯字符数格式可以简洁的描述复杂数据还被js原生支持</li>
<li>web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去</li>
<li>客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样</li>
<li>为了方便客户端使用数据逐渐形成非正式传输协议jsonp</li>
</ol>
<blockquote>
<p><strong>ajax和jsonp的实质核心,区别联系</strong></p>
</blockquote>
<ol>
<li>ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</li>
<li>实质不同:</li>
</ol>
<ul>
<li>ajax的核心是通过xmlHttpRequest获取非本页内容</li>
<li>jsonp的核心是动态添加script标签调用服务器提供的js脚本</li>
</ul>
<ol>
<li>区别联系:</li>
</ol>
<ul>
<li>不在于是否跨域</li>
<li>ajax通过服务端代理一样跨域</li>
<li>jsonp也不并不排斥同域的数据的获取</li>
<li>jsonp是一种方式或者说非强制性的协议</li>
<li>ajax也不一定非要用json格式来传递数据</li>
</ul>
<h2 id="ajax与promise-结合"><a href="#ajax与promise-结合" class="headerlink" title="ajax与promise(结合)"></a>ajax与promise(结合)</h2><ul>
<li>GET:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function proget (url) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;, url, true)</span><br><span class="line"></span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            if (this.readyState === 4) &#123;</span><br><span class="line">                if (this.status === 200) &#123;</span><br><span class="line">                    resolve(this.responseText, this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>POST:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function propost(url, data) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&quot;POST&quot;, url, true)</span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line"></span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            if (this.readyState === 4) &#123;</span><br><span class="line">                if (this.status === 200) &#123;</span><br><span class="line">                    resolve(JSON.parse(this.responseText), this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.send(JSON.stringify(data))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proget(&quot;/http://139.199.2.100/sky/&quot;).then(function (json) &#123;</span><br><span class="line">    console.log(&apos;Contents: &apos;+json);</span><br><span class="line">&#125;,function (error) &#123;</span><br><span class="line">    console.log(&apos;出错了 &apos;, error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="十-vue"><a href="#十-vue" class="headerlink" title="十.vue"></a>十.vue</h1><h2 id="1-生命周期-钩子函数"><a href="#1-生命周期-钩子函数" class="headerlink" title="1.生命周期/钩子函数"></a>1.生命周期/钩子函数</h2><ul>
<li><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
</li>
<li><p>在生命周期执行流程中预留的一个能让我们执行自己代码的地方。叫钩子函数，钩子钩子，挂载我们自己的东西。而钩子函数的实现，基本原理就是callback。</p>
</li>
</ul>
<blockquote>
<p><strong>beforeCreate</strong></p>
</blockquote>
<p>官方说明：在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。<br>解释：这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到<br>适用事件：可以在这加个loading事件，在加载实例时触发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;</span><br><span class="line">  console.log(this.page); // undefined</span><br><span class="line">  console.log&#123;this.showPage); // undefined</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    page: 123</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  showPage() &#123;</span><br><span class="line">    console.log(this.page);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>created</strong></p>
</blockquote>
<p>官方说明：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。<br>解释说明： 这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作<br>适用事件：初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  console.log(this.page); // 123</span><br><span class="line">  console.log&#123;this.showPage); // ...</span><br><span class="line">  $(&apos;select&apos;).select2(); // jQuery插件需要操作相关dom，不会起作用</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    page: 123</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  showPage() &#123;</span><br><span class="line">    console.log(this.page);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>beforeMounte</strong></p>
</blockquote>
<p>官方说明：在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<blockquote>
<p><strong>mounted</strong></p>
</blockquote>
<p>官方说明：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。<br>解释说明：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行<br>适用事件：挂载元素，获取到DOM节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  $(&apos;select&apos;).select2(); // jQuery插件可以正常使用</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</li>
<li>其他几个适用事件：<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作dom</li>
</ul>
<h2 id="2-vue组件的基本过程？"><a href="#2-vue组件的基本过程？" class="headerlink" title="2.vue组件的基本过程？"></a>2.vue组件的基本过程？</h2><ul>
<li>使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</li>
<li>子组件想要改变数据呢？这在vue中是不允许的，因为vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的</li>
</ul>
<h2 id="3-axios"><a href="#3-axios" class="headerlink" title="3.axios"></a>3.axios</h2><blockquote>
<p><strong>特点</strong></p>
</blockquote>
<ol>
<li>Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API</li>
<li>它可以拦截请求和响应</li>
<li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换成JSON类型的数据</li>
<li>安全性更高，客户端支持防御 XSRF</li>
</ol>
<blockquote>
<p><strong>常用方法</strong></p>
</blockquote>
<ol>
<li>axios.get(url[, config])   //get请求用于列表和信息查询</li>
<li>axios.delete(url[, config])  //删除</li>
<li>axios.post(url[, data[, config]])  //post请求用于信息的添加</li>
<li>axios.put(url[, data[, config]])  //更新操作</li>
</ol>
<h2 id="4-双向绑定-MVVM-Router实现（记脑子里）"><a href="#4-双向绑定-MVVM-Router实现（记脑子里）" class="headerlink" title="4.双向绑定/MVVM/Router实现（记脑子里）"></a>4.双向绑定/MVVM/Router实现（记脑子里）</h2><p>(部分)<br>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>具体步骤：</p>
<ol>
<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:</li>
</ol>
<ul>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个update()方法</li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
</ul>
<ol>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><h1 id="十一-web问答题"><a href="#十一-web问答题" class="headerlink" title="十一.web问答题"></a>十一.web问答题</h1><h2 id="1-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#1-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><blockquote>
<p>答：</p>
</blockquote>
<ol>
<li>!DOCTYPE声明位于文档中的最前面，处于html标签之前。告知浏览器以何种模式来渲染文档。 </li>
<li>严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</li>
<li>在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示</li>
<li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 </li>
</ol>
<h2 id="2-HTML与XHTML——二者有什么区别"><a href="#2-HTML与XHTML——二者有什么区别" class="headerlink" title="2.HTML与XHTML——二者有什么区别"></a>2.HTML与XHTML——二者有什么区别</h2><p>答：</p>
<blockquote>
<p><strong>语法上:</strong></p>
</blockquote>
<ul>
<li>XHTML 元素必须被正确地嵌套。</li>
<li>XHTML 元素必须被关闭。</li>
<li>标签名必须用小写字母。</li>
<li>XHTML 文档必须拥有根元素。</li>
</ul>
<blockquote>
<p><strong>作用上:</strong></p>
</blockquote>
<ul>
<li>html是用来显示数据的；xml是用来描述数据、存放数据的，所以可以作为持久化的介质！Html将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。</li>
<li>xml不是HTML的替代品，xml和html是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同，HTML的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。</li>
<li>没有任何行为的XML。与HTML 相似，XML 不进行任何操作。（共同点）</li>
<li>对于XML最好的形容可能是: XML是一种跨平台的，与软、硬件无关的，处理与传输信息的工具</li>
</ul>
<h2 id="3-解释下浮动和它的工作原理？清除浮动的技巧"><a href="#3-解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="3.解释下浮动和它的工作原理？清除浮动的技巧"></a>3.解释下浮动和它的工作原理？清除浮动的技巧</h2><p>答：</p>
<blockquote>
<p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
</blockquote>
<blockquote>
<p><strong>浮动元素引起的问题：</strong></p>
</blockquote>
<ol>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构<br>用 CSS 中的 clear:both; 属性来清除元素的浮动可解决2、3问题</li>
</ol>
<blockquote>
<p><strong>清除浮动的方法：</strong></p>
</blockquote>
<ol>
<li>使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</li>
<li>使用overflow。<br>给包含浮动元素的父标签content添加css属性 overflow:hidden; zoom:1; zoom:1用于兼容IE6。<br>overflow:hidden可以换成overflow:auto，zoom:1可以换成width:100%</li>
<li>使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器<br>content:after{display:block;clear:both;content:””;visibility:hidden;height:0;}</li>
</ol>
<h2 id="4-BFC的布局规则以及触发条件"><a href="#4-BFC的布局规则以及触发条件" class="headerlink" title="4.BFC的布局规则以及触发条件"></a>4.BFC的布局规则以及触发条件</h2><p>答：</p>
<blockquote>
<p><strong>BFC的含义:</strong></p>
</blockquote>
<ul>
<li>块级元素格式化上下文它决定了块级元素如何对它的内容进行布局，以及与其他元素的关系和相互关系</li>
<li>块级元素：父级（是一个块元素）</li>
<li>内容：子元素（是一个块元素）</li>
<li>其他元素：与内容同级别的兄弟元素</li>
<li>相互作用：BFC里的元素与外面的元素不会发生影响 </li>
</ul>
<blockquote>
<p><strong>触发BFC的方式（一下任意一条就可以）</strong></p>
</blockquote>
<ul>
<li>float: left | right</li>
<li>position: fixed | absolute</li>
<li>display: inline-block | table-cell(类似 <td> 和 <th>）此元素会作为一个表格单元格显示) | table-caption(类似 <caption>）此元素会作为一个表格标题显示) | flex | inline-flex</caption></th></td></li>
<li>overflow: hidden(是副作用最小的开启BFC的方式) | scroll | auto</li>
</ul>
<blockquote>
<p><strong>FBC布局与普通文档流布局区别：</strong></p>
</blockquote>
<blockquote>
<blockquote>
<p>普通文档流布局规则</p>
</blockquote>
</blockquote>
<ul>
<li>浮动的元素是不会被父级计算高度</li>
<li>非浮动元素会覆盖浮动元素的位置</li>
<li>margin会传递给父级</li>
<li>两个相邻元素上下margin会重叠</li>
</ul>
<blockquote>
<blockquote>
<p>BFC布局规则</p>
</blockquote>
</blockquote>
<ul>
<li>浮动的元素会被父级计算高度（父级触发了BFC）且BFC的区域不会与float box叠加。</li>
<li>非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</li>
<li>margin不会传递给父级（父级触发了BFC）</li>
<li>Box垂直方向的距离由margin决定。两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li>
</ul>
<h2 id="5-css元素特点"><a href="#5-css元素特点" class="headerlink" title="5.css元素特点"></a>5.css元素特点</h2><blockquote>
<p><strong>块级元素特点：</strong></p>
</blockquote>
<ul>
<li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行)</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置。</li>
<li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 </li>
</ul>
<blockquote>
<p><strong>内联元素特点：</strong></p>
</blockquote>
<ul>
<li>和其他元素都在一行上； </li>
<li>元素的高度、宽度及顶部和底部边距不可设置； </li>
<li>元素的宽度就是它包含的文字或图片的宽度，不可改变。 </li>
</ul>
<blockquote>
<p><strong>内联块状元素特点：</strong></p>
</blockquote>
<ul>
<li>和其他元素都在一行上； </li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置。</li>
</ul>
<h2 id="6-HTML页面呈现的流程"><a href="#6-HTML页面呈现的流程" class="headerlink" title="6. HTML页面呈现的流程:"></a>6. HTML页面呈现的流程:</h2><blockquote>
<p>答：</p>
</blockquote>
<ol>
<li><p>浏览器把获取到的html代码解析成1个Dom树。根节点就是document 对象，这里包含了所有的html  tag，包括display:none隐藏，还有用JS动态添加的元素等。</p>
</li>
<li><p>浏览器把所有样式(主要包括css和浏览器的样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。</p>
</li>
<li><p>dom tree和样式结构体结合后构建呈现树(render tree),render tree有点类似于dom tree，但其实区别有很大，render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到render tree中。注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据css2的标准，render tree中的每个节点都称为box(Box dimensions)，box所有属性：width,height,margin,padding,left,top,border等。总之渲染树为DOM树中可视的部分</p>
</li>
<li><p>计算出渲染树的布局，浏览器就可以根据render tree来绘制页面了</p>
</li>
</ol>
<h2 id="7-1-导致重绘或回流："><a href="#7-1-导致重绘或回流：" class="headerlink" title="7-1.导致重绘或回流："></a>7-1.导致重绘或回流：</h2><p>答：</p>
<ol>
<li>增加、删除、修改DOM结点</li>
<li>使用display:none;的方式隐藏一个结点会导致repaint与reflow，使用visibility:hidden;进行dom隐藏仅仅导致repaint(没有结构性变化，仅仅看不见而已)</li>
<li>移动dom或着该dom进行动画</li>
<li>添加新的样式，或者修改某个样式</li>
<li>用户的一些操作诸如改变浏览器窗口大小，调整字体大小，滚动等等</li>
</ol>
<blockquote>
<p>注意：</p>
</blockquote>
<p>页面首次加载时必引起一次回流和重绘;回流必将引起重绘，而重绘不一定会引起回流</p>
<h2 id="7-2-如何减少Repain和Reflow"><a href="#7-2-如何减少Repain和Reflow" class="headerlink" title="7-2.如何减少Repain和Reflow?"></a>7-2.如何减少Repain和Reflow?</h2><p>答：</p>
<ol>
<li>不要一条一条地修改 DOM 的样式,与其这样，还不如预先定义好css的class然后修改DOM的className，即将多次改变样式属性的操作合并成一次操作</li>
<li>不要把DOM节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性</li>
<li>避免设置多层内联样式</li>
<li>将需要多次重排(动画效果)的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。</li>
<li>避免使用CSS的JavaScript表达式</li>
<li>避免使用table布局</li>
</ol>
<p>（1. table必须在页面完全加载后才显示，没有加载完毕前，table为一片空白，也就是说，需要页面完毕才显示，而div是逐行显示，不需要页面完全加载完毕，就可以一边加载一边显示</p>
<ol>
<li>非表格内容用table来装，不符合标签语义化要求，不利于SEO</li>
<li>table的嵌套性太多，用DIV代码会比较简洁</li>
<li>用DIV+CSS编写出来的文件k数比用table写出来的要小）</li>
</ol>
<h2 id="8-如何对网站的文件和资源进行优化？"><a href="#8-如何对网站的文件和资源进行优化？" class="headerlink" title="8.如何对网站的文件和资源进行优化？"></a>8.如何对网站的文件和资源进行优化？</h2><p>答：</p>
<ol>
<li>文件合并</li>
<li>文件最小化/文件压缩</li>
<li>使用 CDN 托管</li>
<li>缓存的使用（多个域名来提供缓存</li>
</ol>
<h2 id="9-减少页面加载时间的方法-性能优化"><a href="#9-减少页面加载时间的方法-性能优化" class="headerlink" title="9.减少页面加载时间的方法/性能优化"></a>9.减少页面加载时间的方法/性能优化</h2><p>答：</p>
<ol>
<li>减少http请求（合并文件，合并图片）,使用CDN</li>
<li>优化CSS（压缩合并css，如 margin-top, margin-left…) </li>
<li>减少由于HTML标签导致的带宽浪费，例如table的冗余很严重，而我们完全可以用div取代之</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作</li>
<li>优化图片，减小其尺寸(css sprites)</li>
<li>图片预加载，将样式表放在顶部，将Javascript脚本放在底部，加上时间戳</li>
<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） </li>
<li>网址后加斜杠（如  &lt;WWW.campr.com/目录&gt;，会判断这个目录是什么文件类型，或者是目录。）</li>
<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了） </li>
</ol>
<h2 id="10-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#10-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="10.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>10.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h2><p>答：<br>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>
<ol>
<li>使用import方法导入样式表。</li>
<li>将样式表放在页面底部</li>
</ol>
<p>其实原理很清楚：IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系<br><strong>解决方法：</strong>只要在head之间加入一个link或者script元素就可以了</p>
<h2 id="11-null和undefined的区别"><a href="#11-null和undefined的区别" class="headerlink" title="11.null和undefined的区别"></a>11.null和undefined的区别</h2><p>答：<br>null是一个表示”无”的对象，转为数值时为0<br>undefined是一个表示”无”的原始值，转为数值时为NaN</p>
<p>当声明的变量还未被初始化时，变量的默认值为undefined<br>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>
<p>undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ol>
<li>变量被声明了，但没有赋值时，就等于 undefined</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 undefined</li>
<li>对象没有赋值的属性，该属性的值为 undefined</li>
<li>函数没有返回值时，默认返回 undefined</li>
</ol>
<p>null表示“没有对象”，即该处不应该有值。典型用法是：</p>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ol>
<p>注：null==undefined // true (因为null和undefined都会转成false)</p>
<h2 id="12-new操作符具体干了什么呢"><a href="#12-new操作符具体干了什么呢" class="headerlink" title="12.new操作符具体干了什么呢?"></a>12.new操作符具体干了什么呢?</h2><p>答：</p>
<ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this<br>var obj  = {};<br>obj.——proto—— = Base.prototype;<br>Base.call(obj); </li>
</ol>
<h2 id="13-js同步加载、异步加载、延迟加载"><a href="#13-js同步加载、异步加载、延迟加载" class="headerlink" title="13.js同步加载、异步加载、延迟加载"></a>13.js同步加载、异步加载、延迟加载</h2><p>答：</p>
<blockquote>
<p><strong>同步加载：</strong></p>
</blockquote>
<p>同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的，但是会造成页面堵塞</p>
<blockquote>
<p><strong>异步加载：</strong></p>
</blockquote>
<ul>
<li><strong>动态创建DOM方式</strong>（创建script，插入到DOM中，加载完毕后callBack，若把插入script的方法放在一个函数里面，然后放在window的onload方法里面执行可以解决阻塞onload事件触发的问题）</li>
<li><strong>通过ajax(或直接xml)去获取js代码，然后设置节点script.text为返回的responseText</strong>(或直接把responseText放在eval()函数里面执行)</li>
<li><strong>script标签上添加defer或者async属性</strong><br>(所有的defer脚本必须保证按顺序执行的。而async不能保证脚本按顺序执行，他们将在onload事件之前完成。<br>对于支持HTML5的浏览器：实现JS的异步加载只需要在script元素中加上async属性，为了兼容老版本的IE还需加上defer属性)</li>
<li><strong>在父窗口插入一个iframe元素，然后再iframe中执行加载JS的操作</strong></li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/l522703297/article/details/50754695" target="_blank" rel="noopener">https://blog.csdn.net/l522703297/article/details/50754695</a></p>
<blockquote>
<p><strong>延迟加载：</strong></p>
</blockquote>
<p>有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的，将JS切分成许多模块，页面初始化时只加载需要立即执行的JS，然后其它JS的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。</p>
<ul>
<li>使用setTimeout延迟方法的加载时间</li>
</ul>
<h2 id="14-闭包"><a href="#14-闭包" class="headerlink" title="14.闭包"></a>14.闭包</h2><p>答：<br>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<blockquote>
<p><strong>YDKJS</strong>：</p>
</blockquote>
<ol>
<li>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 </li>
<li>IIFE 本身 不是一个闭包的例子，但是它绝对创建了作用域，而且它是我们用来创建可以被闭包的作用域的最常见工具之一。所以 IIFE 确实与闭包有强烈的关联，即便它们本身不行使闭包。</li>
<li>IIFE 本身 不是一个闭包的例子，因为这个函数（就是我们这里命名为“IIFE”的那个）没有在它的词法作用域之外执行。它仍然在它被声明的相同作用域中（那个同时持有 a 的外围/全局作用域）被调用。a 是通过普通的词法作用域查询找到的，不是通过真正的闭包</li>
<li>闭包好像是模块的基础？javaScript 实际上没有动态作用域</li>
</ol>
<blockquote>
<p><strong>闭包有三个特性</strong>:</p>
</blockquote>
<ol>
<li>函数嵌套函数 </li>
<li>函数内部可以引用外部的参数和变量 </li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<blockquote>
<p><strong>模块要求两个关键性质</strong>：</p>
</blockquote>
<ol>
<li>一个被调用的外部包装函数，来创建外围作用域。</li>
<li>这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。</li>
</ol>
<h2 id="15-深浅拷贝"><a href="#15-深浅拷贝" class="headerlink" title="15.深浅拷贝"></a>15.深浅拷贝</h2><p>答：</p>
<blockquote>
<p><strong>浅拷贝：</strong></p>
</blockquote>
<p>只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致obj.c和shallowCopy.c 指向同一块内存地址；会导致引用。slice/concat都是浅拷贝</p>
<blockquote>
<p><strong>深复制：</strong></p>
</blockquote>
<p>它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面obj和shallowCopy的c属性指向同一个对象的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//递归实现</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    var newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    //obj属于基本数据类型,直接返回obj</span><br><span class="line">    if(typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //obj属于数组或对象，遍历它们</span><br><span class="line">        for(var i in obj) &#123;</span><br><span class="line">            newObj[i] = typeof obj[i] === &apos;object&apos; ? deepClone(obj[i]):obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(一句话实现深拷贝)var newObject = JSON.parse(JSON.stringify(oldObject));但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>这2个api的详解<a href="https://blog.csdn.net/qq_24122593/article/details/53046525" target="_blank" rel="noopener">https://blog.csdn.net/qq_24122593/article/details/53046525</a></p>
</li>
<li><p>es6的Object.assign({},state(要拷贝的对象),data（覆盖的对象）) 只是一级属性复制，比浅拷贝多深拷贝了一层而已。</p>
</li>
</ul>
<h2 id="16-内存泄露"><a href="#16-内存泄露" class="headerlink" title="16.内存泄露"></a>16.内存泄露</h2><p>答：</p>
<ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</li>
</ul>
<ol>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包</li>
<li>控制台日志</li>
<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ol>
<h2 id="17-NodeJS的优缺点"><a href="#17-NodeJS的优缺点" class="headerlink" title="17.NodeJS的优缺点"></a>17.NodeJS的优缺点</h2><p>答：</p>
<blockquote>
<p>优点：</p>
</blockquote>
<ol>
<li>因为Node是异步基于事件驱动和无阻塞的，所以非常适合处理高并发</li>
<li>适合I/O密集型应用（高并发/聊天/实时消息推送）</li>
</ol>
<blockquote>
<p>缺点：</p>
</blockquote>
<ol>
<li>不适合CPU密集型应用</li>
<li>单进程，单线程，只支持单核CPU，不能充分利用CPU</li>
<li>开源组件库质量参差不齐，更新快，向下不兼容</li>
</ol>
<h2 id="18-http状态码"><a href="#18-http状态码" class="headerlink" title="18.http状态码"></a>18.http状态码</h2><p>答：</p>
<ul>
<li>100-199：用于指定客户端应响应的某些动作（消息）</li>
<li><p>200-299：用于表示请求成功</p>
</li>
<li><p>300-399：代表需要客户端采取进一步的操作才能完成请求（重定向）</p>
</li>
<li>301：被请求的资源已永久移动到新位置</li>
<li>302：临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。</li>
<li>304：<br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体。</li>
<li><p>307：该状态码与302有相同的含义，但307会遵照浏览器标准，不会从post变为get</p>
</li>
<li><p>400-499：用于指出客户端的错误（请求错误）</p>
</li>
<li>400：语义有误，当前请求无法被服务器理解</li>
<li>401：当前请求需要用户验证</li>
<li>403：服务器拒绝请求</li>
<li><p>408  (请求超时)服务器等候请求时发生超时</p>
</li>
<li><p>500-599：（服务器错误）</p>
</li>
<li>500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</li>
<li>503：由于临时的服务器维护或者过载，服务不可用（过加载）</li>
</ul>
<h2 id="19-一个页面从输入URL到页面加载显示完成-简洁"><a href="#19-一个页面从输入URL到页面加载显示完成-简洁" class="headerlink" title="19.一个页面从输入URL到页面加载显示完成(简洁)"></a>19.一个页面从输入URL到页面加载显示完成(简洁)</h2><p>答：</p>
<blockquote>
<p>分为4个步骤：</p>
</blockquote>
<ol>
<li>浏览器会开启一个线程来处理这个请求，对URL分析判断如果是http协议就按照Web方式来处理，同时在远程DNS服务器上启动一个DNS查询(网址的解析是一个从右向左的过程)。这能使浏览器获得请求对应的 IP 地址。</li>
<li>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li>
<li>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行(GET, POST, PUT, DELETE, OPTIONS, HEAD), 请求报头( Accept, Accept-Charset, Cookie…)和请求正文(传输数据(post..))。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。<br>HTTP响应报文也是由三部分组成: 状态码(xxx), 响应报头(Server, Connection…)和响应报文(通常HTML, CSS, JS, 图片等文件就放在这一部分)。</li>
<li>此时，Web 服务器提供资源服务，客户端开始下载资源。</li>
</ol>
<p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<blockquote>
<p>tcp部分</p>
</blockquote>
<p><a href="https://github.com/OneMay/front-end/blob/master/browser/tcp.md" target="_blank" rel="noopener">https://github.com/OneMay/front-end/blob/master/browser/tcp.md</a></p>
<h2 id="20-模块化commonjs和AMD-CMD"><a href="#20-模块化commonjs和AMD-CMD" class="headerlink" title="20.模块化commonjs和AMD/CMD"></a>20.模块化commonjs和AMD/CMD</h2><p>答：</p>
<blockquote>
<p><strong>共同点：</strong></p>
</blockquote>
<p>两者都是为了实现模块化编程而出现的，对于大型项目，参与人数多，代码逻辑复杂，是最适合使用模块化的思想来完成整个项目的。同时采用这种思想也很便于对整个项目进行管控。</p>
<blockquote>
<p><strong>区别：</strong></p>
</blockquote>
<ol>
<li><p>CommonJS是适用于服务器端的，著名的Node执行环境就是采用的CommonJS模式。它是同步加载不同模块文件。之所以采用同步，是因为模块文件都存放在服务器的各个硬盘上，实际的加载时间就是硬盘的文件读取时间。</p>
</li>
<li><p>AMD，Asynchronous Module Definition，即异步模块定义。它是适用于浏览器端的一种模块加载方式。从名字可知，AMD采用的是异步加载方式（js中最典型的异步例子就是ajax）。浏览器需要使用的js文件（第一次加载，忽略缓存）都存放在服务器端，从服务器端加载文件到浏览器是受网速等各种环境因素的影响的，如果采用同步加载方式，一旦js文件加载受阻，后续在排队等待执行的js语句将执行出错，会导致页面的‘假死’，用户无法使用一些交互。所以在浏览器端是无法使用CommonJS的模式的。目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js<br>require.js—&gt;<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></p>
</li>
<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置。</p>
</li>
<li><p>AMD的API默认是一个当多个用,CMD的API严格区分,推崇职责单一,比如AMD里，require 分全局require和局部require，都叫require。CMD里，没有全局require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>
</li>
</ol>
<h2 id="21-animation和transition"><a href="#21-animation和transition" class="headerlink" title="21.animation和transition"></a>21.animation和transition</h2><p>答：</p>
<blockquote>
<p><strong>transition</strong></p>
</blockquote>
<ul>
<li><p>触发过渡：<br>单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有：<br>:hoever :focus :checked 媒体查询触发 JavaScript触发</p>
</li>
<li><p>局限性：</p>
</li>
</ul>
<ol>
<li>transition需要事件触发，所以没法在网页加载时自动发生。 </li>
<li>transition是一次性的，不能重复发生，除非一再触发。 </li>
<li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 </li>
<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 </li>
</ol>
<blockquote>
<p><strong>animation</strong></p>
</blockquote>
<ul>
<li>CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成： </li>
</ul>
<ol>
<li>通过类似Flash动画中的帧来声明一个动画</li>
<li>在animation属性中调用关键帧声明的动画<br>Note：animation属性到目前位置得到了大多数浏览器的支持，但是需要添加浏览器前缀！</li>
</ol>
<p>参考链接：<br><a href="https://blog.csdn.net/u014607184/article/details/51801393" target="_blank" rel="noopener">https://blog.csdn.net/u014607184/article/details/51801393</a><br><a href="https://blog.csdn.net/XIAOZHUXMEN/article/details/52003135" target="_blank" rel="noopener">https://blog.csdn.net/XIAOZHUXMEN/article/details/52003135</a><br><a href="https://blog.csdn.net/picking_up_stones/article/details/54909908" target="_blank" rel="noopener">https://blog.csdn.net/picking_up_stones/article/details/54909908</a>animation解释</p>
<h2 id="22-前端的安全问题"><a href="#22-前端的安全问题" class="headerlink" title="22.前端的安全问题"></a>22.前端的安全问题</h2><p>答：</p>
<ul>
<li><p>XSS更偏向于代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了</p>
</li>
<li><p>跨站脚本攻击(XSS攻击)：脚本可能包含一个跨域的get请求（img，iframe），把当前用户的cookie包含在在url里发送出去，这样，黑客就能拿到用户的cookie然后为所欲为。如何防范？</p>
</li>
</ul>
<ol>
<li>防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。</li>
<li>Cookie 防盗，在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对ip和cookie进行绑定，一旦检测异常，立马让用户重新登录。</li>
</ol>
<ul>
<li>跨站请求伪造(CSRF攻击)通过伪造身份提交POST和GET请求来进行跨域的攻击,如何防范？<br>注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源</li>
</ul>
<ol>
<li><strong>关键操作只接受POST请求</strong></li>
<li><strong>验证码</strong>，CSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。</li>
<li><strong>检测 Referer</strong>，常见的互联网页面与页面之间是存在联系的，比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中，通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到Referer的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。</li>
<li><strong>Token</strong>，CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击</li>
</ol>
<ul>
<li>SQL注入攻击</li>
</ul>
<h2 id="23-DOM级别问题"><a href="#23-DOM级别问题" class="headerlink" title="23.DOM级别问题"></a>23.DOM级别问题</h2><p>答：</p>
<blockquote>
<p>DOM0级只是DOM历史坐标中的一个参照点而已</p>
</blockquote>
<blockquote>
<p>DOM1级由两个模块组成：DOM核心（DOM Core）和DOM HTML</p>
</blockquote>
<ol>
<li>DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。</li>
<li>DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法</li>
</ol>
<blockquote>
<p>DOM2级扩充了鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持</p>
</blockquote>
<ol>
<li>DOM视图（DOM Views）：定义了跟踪不同文档（例如，应用CSS之前和之后的文档）视图的接口</li>
<li>DOM事件（DOM Events）：定义了事件和事件处理的接口</li>
<li>DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口</li>
<li>DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口</li>
</ol>
<blockquote>
<p>DOM3级则引入了以统一方式加载和保存文档的方法</p>
</blockquote>
<ol>
<li>在DOM加载和保存（DOM Load and Save）模块中定义</li>
<li>新增了验证文档的方法–在DOM验证(DOM Validation模块中定义</li>
<li>DOM3级也对DOM核心进行了扩展，开始支持XML 1.0规范，涉及XML Infoset、XPath和XML Base</li>
</ol>
<h2 id="24-h5语义化与结构、表现、行为分离"><a href="#24-h5语义化与结构、表现、行为分离" class="headerlink" title="24.h5语义化与结构、表现、行为分离"></a>24.h5语义化与结构、表现、行为分离</h2><p>答：</p>
<ul>
<li><p>我所理解的语义化就是让代码更让人容易理解或者说是去掉样式的时候能够让页面呈现出清晰的结构。通过用合理的有一定语义的英文字母（标签）标记，以及其特有的属性去格式化文档及其内容。技术上能够有利于与SEO建立良好沟通，爬虫抓取更多有效信息，而且在团队开发中增加了可读性与规范性来提高合作的工作效率。<br>在项目中比如在用于规定独立的流内容时会选择使用H5的figure与figcaption标签；需要强调的文本会选择使用strong或者em标签；以及经常用的section、footer等等<br>在样式命名上也会比较注意所使用的英文是否贴切</p>
</li>
<li><p>首先在功能上简单来说，HTML结构层是网页最重要的基础，HTML标签给予内容含义。CSS表现层则是让网页的表现更丰富，说白了就是修饰HTML如何显示。JavaScript行为层就是为页面增加交互。分成这三层同样不仅是为了可读与合作，还在开发的逻辑层面当中提供了更加清晰的条件思路，有利于整体项目的修改与维护。<br>通常我们都会将html、css、js文件分开，这样我们就能够在出现问题的时候更便捷的去修改某一个地方。<br>在大型项目中，我们还会写一个需要经常使用的js函数或者css样式的类库文件，在需要时引进它就行，解决代码的臃肿问题，并且让我们可以更容易结合mvc或者是最近的mvvm思想去前端开发。</p>
</li>
</ul>
<h2 id="25-HTTP1-0、HTTP-1-1、HTTP-2-0之间的主要区别"><a href="#25-HTTP1-0、HTTP-1-1、HTTP-2-0之间的主要区别" class="headerlink" title="25.HTTP1.0、HTTP 1.1、HTTP 2.0之间的主要区别"></a>25.HTTP1.0、HTTP 1.1、HTTP 2.0之间的主要区别</h2><p>答：</p>
<blockquote>
<p><strong>HTTP1.0与HTTP 1.1的主要区别:</strong></p>
</blockquote>
<ol>
<li><strong>长连接</strong>(HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接)</li>
<li><strong>带宽优化及网络连接的使用</strong>(HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器)</li>
<li><strong>HOST域</strong>(可以用web server（例如tomat），设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口,HTTP1.0是没有host域的)</li>
<li><strong>缓存处理</strong></li>
<li><strong>错误通知的管理</strong></li>
</ol>
<blockquote>
<p><strong>HTTP1.1与HTTP 2.0的主要区别:</strong></p>
</blockquote>
<ol>
<li><strong>多路复用</strong>(即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面)</li>
<li><strong>二进制分帧而非文本格式</strong></li>
<li><strong>首部压缩</strong>(HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快)</li>
<li><strong>服务器推送</strong>(服务端推送是一种在客户端请求之前发送数据的机制)</li>
</ol>
<p>参考链接：<br><a href="https://blog.csdn.net/m_xiaoer/article/details/72903355" target="_blank" rel="noopener">https://blog.csdn.net/m_xiaoer/article/details/72903355</a></p>
<h2 id="26-js对DOM的操作优化"><a href="#26-js对DOM的操作优化" class="headerlink" title="26.js对DOM的操作优化"></a>26.js对DOM的操作优化</h2><p>答：</p>
<blockquote>
<p><strong>1.批量增加Dom</strong></p>
</blockquote>
<ul>
<li>比如问到（如果一个ul里面插入1000个li节点，怎么插入？等）</li>
<li>尽量使用修改innerHTML的方式而不是用appendChild的方式; 因为使用innerHTML开销更小，速度更快，同时也更加内存安全</li>
<li>用innerHTML方式添加时，一定不要在循环中使用 innerHTML += 的方式添加，这样反而会使速度减慢; 而是应该中间用array缓存起来，循环结束后调用xx.innerHTML=array.join(“”);的方式，或者至少保存到string中再插到innerHTML中</li>
</ul>
<blockquote>
<p><strong>2.单个增加Dom</strong></p>
</blockquote>
<ul>
<li>对于有动态内容的节点来说，为其添加子节点尽量使用 DOM append的方式</li>
<li>因为DOM append不会影响到其他的节点;而如果修改innerHTML属性的话，该父节点的所有子节点都会从DOM树中剥离，再根据新的innerHTML值来重绘子节点DOM树，所有注册到原来子节点的事件也会失效.这点要特别注意，也就是说，本来子结点是有个事件的，你在父节点上搞个parentNode.innerHTML += ‘string’，那么本来有事件的那个子节点也就没有事件了。(事件委托是不受影响的!!!!)</li>
</ul>
<blockquote>
<p><strong>3.创建Dom节点</strong></p>
</blockquote>
<ul>
<li>用 createElement方式创建一个dom节点,有一个很重要的细节: 在执行完createElement代码之后,应该马上append到dom树中，否则,如果在将这个孤立节点加载到dom树之前所做的赋值它的属性和innerHTML的操作都会引发该dom片段内存无法回收的问题. 这个不起眼细节，一旦遇到大量dom增删操作，就会引发内存的灾难</li>
</ul>
<blockquote>
<p><strong>4.删除Dom节点</strong></p>
</blockquote>
<ul>
<li>删除dom节点之前,一定要删除注册在该节点上的事件，不管是不是用addEventListner方式注册的事件，否则将会产生无法回收的内存</li>
<li>在removeChild和innerHTML=””二者之间，尽量选择后者.因为在内存泄露监测工具中监测的结果是用removeChild无法有效地释放DOM节点.</li>
</ul>
<h2 id="27-em与rem"><a href="#27-em与rem" class="headerlink" title="27.em与rem"></a>27.em与rem</h2><p>答：</p>
<blockquote>
<p><strong>联系：</strong></p>
</blockquote>
<p>rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值16</p>
<blockquote>
<p><strong>区别:</strong></p>
</blockquote>
<ul>
<li>rem 单位翻译为像素值是由 <strong>html(根)元素</strong>的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。</li>
<li>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从<strong>父元素</strong>继承过来的字体大小，除非显式重写与一个具体单位</li>
</ul>
<blockquote>
<p><strong>使用:</strong></p>
</blockquote>
<ul>
<li>使用 rem 单位的主要目的应该是确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小。(字体，媒体查询)</li>
<li>使用 em 单位的主要目的应该是允许保持在一个特定的设计元素范围内的可扩展性（padding、 margin、 width、 height和line-height等值）</li>
</ul>
<h2 id="28-js事件流"><a href="#28-js事件流" class="headerlink" title="28.js事件流"></a>28.js事件流</h2><p>答：</p>
<ul>
<li>当元素注册了事件,此事件的作用范围为:1.元素自己所占页面空间部分加嵌套元素所占空间范围(若嵌套元素覆盖在容器元素上，则事件的作用范围为容器元素自身所占空间大小)</li>
<li>当容器元素及其嵌套元素都在<strong>冒泡阶段</strong>调用事件处理程序时：事件按事件冒泡的顺序执行事件处理程序(从里到外)</li>
<li>当容器元素及其嵌套元素都在<strong>捕获阶段</strong>调用事件处理程序时：事件按事件捕获的顺序执行事件处理程序(从外到里)</li>
<li>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段==&gt;处于目标阶段（且当事件处于目标阶段时，事件调用顺序决定于绑定事件的书写顺序）==&gt;事件冒泡阶段。首先发生的是事件捕获阶段，为截获事件提供了机会。然后是实际的目标接收事件。最后一个阶段是冒泡阶段</li>
</ul>
<h2 id="29-cookie"><a href="#29-cookie" class="headerlink" title="29.cookie"></a>29.cookie</h2><p>答：</p>
<ul>
<li>Cookie的本身作用是与服务器进行交互(cookie是跟域名绑定的,cookie是不能跨域访问的，但是在二级域名是可以共享cookie的)，作为HTTP规范的一部分而存在 ，但是它有本地存储的功能，于是就被借用存储(document.cookie=…获取和修改)javascript能够用document对象的cookie属性对cookie进行操作。</li>
<li><p>Cookie采用的是客户端的会话状态的一种储存机制。它是服务器在本地机器上存储的小段文本或者是内存中的一段数据，并随每一个请求发送至同一个服务器</p>
</li>
<li><p>cookie的四个可选属性: </p>
</li>
</ul>
<ol>
<li><strong>cookie的生存期属性:</strong>expires;默认情况下,cookie只在浏览器会话期存在.退出浏览器就丢失;可以用expires设置时间;退出浏览器后就不会丢失并存为客户端浏览器的cookie文件;过了时间后cookie失效,还会自动删除cookie文件. </li>
<li><strong>path属性:</strong>默认情况下,在同一个目录下文件可以调用;<br>例如:<a href="http://hanj.com/c1/1.html" target="_blank" rel="noopener">http://hanj.com/c1/1.html</a>设置的cookie可以被<a href="http://hanj.com/c1/2.html" target="_blank" rel="noopener">http://hanj.com/c1/2.html</a>调用.但不能被<a href="http://hanj.com/c2/" target="_blank" rel="noopener">http://hanj.com/c2/</a>目录下的文件调用; 但如把path属性设成”/“;则在<a href="http://hanj.com/" target="_blank" rel="noopener">http://hanj.com/</a>下的所有文件都可调用此cookie.  </li>
<li><strong>domain属性:</strong>例如设成”.hanj.com”则在.hanj.com下的所有服务器下的文件都可以调用cookie.  </li>
<li><strong>安全属性:</strong>默认情况下为false;用http协议不安全传输;true:用https等协议安全传输.  </li>
</ol>
<ul>
<li>cookie的局限性:<br>浏览器最多保存300个cookie;为单个web服务器的最多只能保存20个cookie;每个cookie不能超过4000个字节.存储量太小/api太简单</li>
</ul>
<p>-如何携带cookie进行跨域:</p>
<ol>
<li>设置xhr.withCredentials = true;而且你的服务器必须返回头部带有’Access-Control-Allow-Credentials: true’的回应 </li>
<li>关于跨域的Access-Control-Allow-Origin头，再像上面那样设置为*就不行了(可以看看跨域那一节的CORS，相比JSONP只能发GET请求，CORS允许任何类型的请求，但是jsonp可以在不支持cors的浏览器中使用)，会报错。在Access-Control-Allow-Credentials设置为true的时候，Access-Control-Allow-Origin不能被设置为通配符。所以解决思路就是在返回的时候设置为请求头中Origin的值 </li>
</ol>
<h2 id="30-cookie与session"><a href="#30-cookie与session" class="headerlink" title="30.cookie与session"></a>30.cookie与session</h2><p>答：</p>
<blockquote>
<p>区别：</p>
</blockquote>
<p>Cookie保存在客户端浏览器中，而Session保存在服务器上。Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了<br>cookie的生命周期是累计的;session的生命周期是间隔的</p>
<blockquote>
<p>session产生的session_id放在cookie里面，如果用户把cookie禁止掉，是不是session也不能用了呢?</p>
</blockquote>
<p>禁止掉cookie后，session当然可以用，不过通过其他的方式来获得这个sessionid，比如，可以跟在url的后面，或者以表单的形势提交到服务器端。从而使服务器端了解客户端的状态</p>
<blockquote>
<p>为什么说session 比cookie更安全?</p>
</blockquote>
<ul>
<li>真正的cookie存在于客户端硬盘上的一个文本文件，如果两者一样的话，只要cookie就好了，让客户端来分提服务器的负担，并且对于用户来说又是透明的。但实际上不是。</li>
<li>session的sessionID是放在cookie里，要想攻破session的话，得分两步：</li>
</ul>
<ol>
<li>得到sessionID。攻破cookie后，你要得到sessionID,sessionID是要有人登录，或者启动session_start才会有，你不知道什么时候会有人登录。</li>
<li>有效sessionID。sessionID是加密的，第二次session_start的时候，前一次的sessionID就没有用了，session过期时sessionid也会失效，想在短时间内功破加了密的 sessionID很难。session是针对某一次通信而言，会话结束session也就随着消失了</li>
</ol>
<blockquote>
<p>使session失效的方法：</p>
</blockquote>
<p>1.关闭tomcat  2.重启web应用  3.session时间到  4.无效的session</p>
<h2 id="31-单例模式"><a href="#31-单例模式" class="headerlink" title="31.单例模式"></a>31.单例模式</h2><p>答：</p>
<blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<ol>
<li>单例模式声明一个命名空间，它生成一个唯一的全局变量，一个命名空间，处理多需求页面，多人开发时就能很好的解决命名冲突的问题，以及可以更好的维护代码，更好的控制代码</li>
<li>通过单例模式创建的对象变量中可以更快速的找到问题，从而解决，这大大减少的问题修复的时间以及系统加载的时间</li>
<li>在实现同一个功能的地方比通过new新创建对象对内存对资源的占用更据优势</li>
</ol>
<blockquote>
<p><strong>缺点：</strong></p>
</blockquote>
<ol>
<li>它的扩展性不好，对一个单例对象里面的方法重写时会破坏原有的需求，就如上述中的init,如果你写下如下代码 mapleTao.init=function(){console.log(1)};那么init方法就会把原有的方法替换，从而改变了该方法的实现，会破坏它的功能。</li>
<li>灵活性不好， 当某个需要实现该功能的需求需要变动时，而其他的又不需要变动时，单例对象就不好处理了，所以单例对象是不能随意改的</li>
</ol>
<blockquote>
<p>惰性单例指的是在需要的时候才创建对象的实例。惰性单例是单例模式的重点</p>
</blockquote>
<h2 id="32-webpack打包原理"><a href="#32-webpack打包原理" class="headerlink" title="32.webpack打包原理"></a>32.webpack打包原理</h2><p>答：</p>
<ul>
<li>简要概括就是exports和require，然后自动加载入口模块，控制缓存模块</li>
<li>一切皆模块：<br>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(“myJSfile.js”)亦可以require(“myCSSfile.css”)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。</li>
<li>按需加载：<br>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。</li>
<li>文件管理：<br>每个文件都是一个资源，可以用require/import导入js<br>每个入口文件会把自己所依赖(即require)的资源全部打包在一起，一个资源多次引用的话，只会打包一份<br>对于多个入口的情况，其实就是分别独立的执行单个入口情况，每个入口文件不相干(可用CommonsChunkPlugin优化)</li>
<li>打包原理：<br>把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。</li>
</ul>
<h2 id="33-关于DNS的获取流程"><a href="#33-关于DNS的获取流程" class="headerlink" title="33.关于DNS的获取流程"></a>33.关于DNS的获取流程</h2><p>答：</p>
<ul>
<li>DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。具体过程如下：</li>
</ul>
<ol>
<li>用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了</li>
<li>浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a><br>, 并将这个主机名传送给DNS应用的客户端,网址的解析是一个从右向左的过程</li>
<li>DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）</li>
<li>该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址</li>
<li>一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接</li>
</ol>
<ul>
<li>DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li>
</ul>
<h2 id="34-HTTP缓存（简洁）"><a href="#34-HTTP缓存（简洁）" class="headerlink" title="34.HTTP缓存（简洁）"></a>34.HTTP缓存（简洁）</h2><p>答：<br><img src="/images/http1.jpg" alt=""></p>
<ol>
<li><p>缓存存储策略：用来确定 Http 响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存<br>-（Cache-Control ）<br>这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端（描述的是一个相对时间）</p>
</li>
<li><p>缓存过期策略：客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据<br>-（Expires）<br>这个策略的作用也只有一个，那就是决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）（描述的是绝对时间）</p>
</li>
<li><p>缓存对比策略：将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端，缓存数据是否仍有效，进而决定是否要重发数据。协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
</li>
</ol>
<p><img src="/images/http2.jpg" alt=""><br>所以最终结果是：浏览器会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比：<br>a）对比失败：服务器返回200并重发数据，客户端接收到数据后展示，并刷新本地缓存。<br>b）对比成功：服务器返回304且不重发数据，客户端收到304状态码后从本地读取缓存数据。</p>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：<br>1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
<h2 id="35-浏览器缓存（客户端缓存-gt-简洁）"><a href="#35-浏览器缓存（客户端缓存-gt-简洁）" class="headerlink" title="35.浏览器缓存（客户端缓存-&gt;简洁）"></a>35.浏览器缓存（客户端缓存-&gt;简洁）</h2><p>答：</p>
<blockquote>
<p><strong>强缓存</strong>:</p>
</blockquote>
<ul>
<li>强缓存过程：</li>
</ul>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。<br>（Cache-Control描述的是一个相对时间，过程和上述差不多）</li>
</ol>
<ul>
<li>2种方式来设置是否启用强缓存：</li>
</ul>
<ol>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ol>
<ul>
<li>由于在开发的时候不会专门去配置强缓存,解决方法：</li>
</ul>
<ol>
<li>直接ctrl+f5</li>
<li>使用浏览器的隐私模式开发</li>
<li>在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001</li>
<li>如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数</li>
<li>如果你用的是grunt和gulp这种前端工具开发</li>
</ol>
<blockquote>
<p><strong>协商缓存</strong>:</p>
</blockquote>
<ul>
<li><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。 </p>
</li>
<li><p>协商缓存过程：</p>
</li>
</ul>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<strong>respone</strong>的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</li>
<li>浏览器再次跟服务器请求这个资源时，在<strong>request</strong>的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header<br>（【ETag、If-None-Match】与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：）</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</li>
</ol>
<ul>
<li>注意：<br>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）<br>如果不启用强缓存的话，协商缓存根本没有意义。</li>
</ul>
<blockquote>
<p><strong>大公司的静态资源优化方案</strong></p>
</blockquote>
<ol>
<li>配置超长时间的本地缓存(还要强缓存) —— 节省带宽，提高性能</li>
<li>采用内容摘要作为缓存更新依据 —— 精确的缓存控制</li>
<li>静态资源CDN部署 —— 优化网络请求</li>
<li>更资源发布路径实现非覆盖式发布 —— 平滑升级</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/12/还是选择了Vue/" rel="next" title="还是选择了Vue~">
                <i class="fa fa-chevron-left"></i> 还是选择了Vue~
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/hsq.png"
                alt="lsj" />
            
              <p class="site-author-name" itemprop="name">lsj</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。"><span class="nav-number">1.</span> <span class="nav-text">一. 比较实用的jq获取表单数据并遍历数据的方法，name是指每条表单的name属性。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-基础函数小结"><span class="nav-number">2.</span> <span class="nav-text">二.基础函数小结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js类："><span class="nav-number">2.1.</span> <span class="nav-text">js类：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html-css类："><span class="nav-number">2.2.</span> <span class="nav-text">html+css类：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http类："><span class="nav-number">2.3.</span> <span class="nav-text">http类：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql类"><span class="nav-number">2.4.</span> <span class="nav-text">sql类:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-JS专题问题："><span class="nav-number">3.</span> <span class="nav-text">三.JS专题问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-setTimeout"><span class="nav-number">3.1.</span> <span class="nav-text">1(setTimeout)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-js的map和foreach原来不能改变当前索引的值："><span class="nav-number">3.2.</span> <span class="nav-text">2.js的map和foreach原来不能改变当前索引的值：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-推荐在循环对象属性的时候，使用for…in-在遍历数组的时候的时候使用for…of。"><span class="nav-number">3.3.</span> <span class="nav-text">3.推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-理解一下call与arguments"><span class="nav-number">3.4.</span> <span class="nav-text">4.理解一下call与arguments~</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-LHS查询和RHS查询"><span class="nav-number">3.5.</span> <span class="nav-text">5.LHS查询和RHS查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-javascript中的异步-macrotask-和-microtask"><span class="nav-number">3.6.</span> <span class="nav-text">6.javascript中的异步 macrotask 和 microtask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-忘记了this就看这个"><span class="nav-number">3.7.</span> <span class="nav-text">7.忘记了this就看这个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-事件代理或事件委托："><span class="nav-number">3.8.</span> <span class="nav-text">8.事件代理或事件委托：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-经典闭包题看一下"><span class="nav-number">3.9.</span> <span class="nav-text">9.经典闭包题看一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-函数防抖-amp-函数节流"><span class="nav-number">3.10.</span> <span class="nav-text">10.函数防抖&amp;函数节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数防抖："><span class="nav-number">3.10.1.</span> <span class="nav-text">函数防抖：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数节流："><span class="nav-number">3.10.2.</span> <span class="nav-text">函数节流：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-判断js类型"><span class="nav-number">3.11.</span> <span class="nav-text">11.判断js类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-javascript对象的8种创建方式"><span class="nav-number">3.12.</span> <span class="nav-text">12.javascript对象的8种创建方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-javascript继承6种方法"><span class="nav-number">3.13.</span> <span class="nav-text">13.javascript继承6种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-js实现懒加载"><span class="nav-number">3.14.</span> <span class="nav-text">14.js实现懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-分时函数？"><span class="nav-number">3.15.</span> <span class="nav-text">15.分时函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-兼容ie和chrome的检测滚动条是否已经在底部"><span class="nav-number">3.16.</span> <span class="nav-text">16.兼容ie和chrome的检测滚动条是否已经在底部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-常见的兼容的问题总结"><span class="nav-number">3.17.</span> <span class="nav-text">17.常见的兼容的问题总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-往数据库一个字段存对象问题："><span class="nav-number">4.</span> <span class="nav-text">四.往数据库一个字段存对象问题：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-原型链与闭包"><span class="nav-number">5.</span> <span class="nav-text">五.原型链与闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六-Promise"><span class="nav-number">6.</span> <span class="nav-text">六.Promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七-跨域了解一下"><span class="nav-number">7.</span> <span class="nav-text">七.跨域了解一下~</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Cookie-document-domain"><span class="nav-number">7.1.</span> <span class="nav-text">1/Cookie(document.domain)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。"><span class="nav-number">7.2.</span> <span class="nav-text">2/iframe对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#片段标识符（fragment-identifier）指的是，URL的-号后面的部分，"><span class="nav-number">7.2.1.</span> <span class="nav-text">片段标识符（fragment identifier）指的是，URL的#号后面的部分，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-name"><span class="nav-number">7.2.2.</span> <span class="nav-text">window.name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-postMessage"><span class="nav-number">7.2.3.</span> <span class="nav-text">window.postMessage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-AJAX：（JSONP-WebSocket-CORS）"><span class="nav-number">7.3.</span> <span class="nav-text">3/AJAX：（JSONP/WebSocket/CORS）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSONP"><span class="nav-number">7.3.1.</span> <span class="nav-text">JSONP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket是一种通信协议，使用ws-（非加密）和wss-（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。"><span class="nav-number">7.3.2.</span> <span class="nav-text">WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS是跨源资源分享（Cross-Origin-Resource-Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。"><span class="nav-number">7.3.3.</span> <span class="nav-text">CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八-笔记算法"><span class="nav-number">8.</span> <span class="nav-text">八.笔记算法= =</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-最大公约数-amp-最小公倍数"><span class="nav-number">8.1.</span> <span class="nav-text">1.最大公约数&amp;最小公倍数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-回文"><span class="nav-number">8.2.</span> <span class="nav-text">2.回文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-排序"><span class="nav-number">8.3.</span> <span class="nav-text">3.排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九-Ajax-Asynchronous-JavaScript-and-XML"><span class="nav-number">9.</span> <span class="nav-text">九.Ajax(Asynchronous JavaScript and XML)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax的原理"><span class="nav-number">9.1.</span> <span class="nav-text">ajax的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax的过程-问答题"><span class="nav-number">9.2.</span> <span class="nav-text">ajax的过程(问答题)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax的优缺点"><span class="nav-number">9.3.</span> <span class="nav-text">ajax的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax与jsonp-例子在跨域那个点有"><span class="nav-number">9.4.</span> <span class="nav-text">ajax与jsonp(例子在跨域那个点有)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax与promise-结合"><span class="nav-number">9.5.</span> <span class="nav-text">ajax与promise(结合)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十-vue"><span class="nav-number">10.</span> <span class="nav-text">十.vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-生命周期-钩子函数"><span class="nav-number">10.1.</span> <span class="nav-text">1.生命周期/钩子函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-vue组件的基本过程？"><span class="nav-number">10.2.</span> <span class="nav-text">2.vue组件的基本过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-axios"><span class="nav-number">10.3.</span> <span class="nav-text">3.axios</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-双向绑定-MVVM-Router实现（记脑子里）"><span class="nav-number">10.4.</span> <span class="nav-text">4.双向绑定/MVVM/Router实现（记脑子里）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5"><span class="nav-number">10.5.</span> <span class="nav-text">5.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一-web问答题"><span class="nav-number">11.</span> <span class="nav-text">十一.web问答题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><span class="nav-number">11.1.</span> <span class="nav-text">1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HTML与XHTML——二者有什么区别"><span class="nav-number">11.2.</span> <span class="nav-text">2.HTML与XHTML——二者有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-解释下浮动和它的工作原理？清除浮动的技巧"><span class="nav-number">11.3.</span> <span class="nav-text">3.解释下浮动和它的工作原理？清除浮动的技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-BFC的布局规则以及触发条件"><span class="nav-number">11.4.</span> <span class="nav-text">4.BFC的布局规则以及触发条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-css元素特点"><span class="nav-number">11.5.</span> <span class="nav-text">5.css元素特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-HTML页面呈现的流程"><span class="nav-number">11.6.</span> <span class="nav-text">6. HTML页面呈现的流程:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-导致重绘或回流："><span class="nav-number">11.7.</span> <span class="nav-text">7-1.导致重绘或回流：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-如何减少Repain和Reflow"><span class="nav-number">11.8.</span> <span class="nav-text">7-2.如何减少Repain和Reflow?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-如何对网站的文件和资源进行优化？"><span class="nav-number">11.9.</span> <span class="nav-text">8.如何对网站的文件和资源进行优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-减少页面加载时间的方法-性能优化"><span class="nav-number">11.10.</span> <span class="nav-text">9.减少页面加载时间的方法/性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><span class="nav-number">11.11.</span> <span class="nav-text">10.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-null和undefined的区别"><span class="nav-number">11.12.</span> <span class="nav-text">11.null和undefined的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-new操作符具体干了什么呢"><span class="nav-number">11.13.</span> <span class="nav-text">12.new操作符具体干了什么呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-js同步加载、异步加载、延迟加载"><span class="nav-number">11.14.</span> <span class="nav-text">13.js同步加载、异步加载、延迟加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-闭包"><span class="nav-number">11.15.</span> <span class="nav-text">14.闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-深浅拷贝"><span class="nav-number">11.16.</span> <span class="nav-text">15.深浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-内存泄露"><span class="nav-number">11.17.</span> <span class="nav-text">16.内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-NodeJS的优缺点"><span class="nav-number">11.18.</span> <span class="nav-text">17.NodeJS的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-http状态码"><span class="nav-number">11.19.</span> <span class="nav-text">18.http状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-一个页面从输入URL到页面加载显示完成-简洁"><span class="nav-number">11.20.</span> <span class="nav-text">19.一个页面从输入URL到页面加载显示完成(简洁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-模块化commonjs和AMD-CMD"><span class="nav-number">11.21.</span> <span class="nav-text">20.模块化commonjs和AMD/CMD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-animation和transition"><span class="nav-number">11.22.</span> <span class="nav-text">21.animation和transition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-前端的安全问题"><span class="nav-number">11.23.</span> <span class="nav-text">22.前端的安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-DOM级别问题"><span class="nav-number">11.24.</span> <span class="nav-text">23.DOM级别问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-h5语义化与结构、表现、行为分离"><span class="nav-number">11.25.</span> <span class="nav-text">24.h5语义化与结构、表现、行为分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-HTTP1-0、HTTP-1-1、HTTP-2-0之间的主要区别"><span class="nav-number">11.26.</span> <span class="nav-text">25.HTTP1.0、HTTP 1.1、HTTP 2.0之间的主要区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-js对DOM的操作优化"><span class="nav-number">11.27.</span> <span class="nav-text">26.js对DOM的操作优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-em与rem"><span class="nav-number">11.28.</span> <span class="nav-text">27.em与rem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-js事件流"><span class="nav-number">11.29.</span> <span class="nav-text">28.js事件流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-cookie"><span class="nav-number">11.30.</span> <span class="nav-text">29.cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-cookie与session"><span class="nav-number">11.31.</span> <span class="nav-text">30.cookie与session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-单例模式"><span class="nav-number">11.32.</span> <span class="nav-text">31.单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-webpack打包原理"><span class="nav-number">11.33.</span> <span class="nav-text">32.webpack打包原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-关于DNS的获取流程"><span class="nav-number">11.34.</span> <span class="nav-text">33.关于DNS的获取流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-HTTP缓存（简洁）"><span class="nav-number">11.35.</span> <span class="nav-text">34.HTTP缓存（简洁）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-浏览器缓存（客户端缓存-gt-简洁）"><span class="nav-number">11.36.</span> <span class="nav-text">35.浏览器缓存（客户端缓存-&gt;简洁）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsj</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
